{"version":3,"file":"index-95487546.js","sources":["../node_modules/codec-parser/src/constants.js","../node_modules/codec-parser/src/utilities.js","../node_modules/codec-parser/src/codecs/HeaderCache.js","../node_modules/codec-parser/src/globals.js","../node_modules/codec-parser/src/codecs/Parser.js","../node_modules/codec-parser/src/containers/Frame.js","../node_modules/codec-parser/src/codecs/CodecFrame.js","../node_modules/codec-parser/src/metadata/ID3v2.js","../node_modules/codec-parser/src/codecs/CodecHeader.js","../node_modules/codec-parser/src/codecs/mpeg/MPEGHeader.js","../node_modules/codec-parser/src/codecs/mpeg/MPEGFrame.js","../node_modules/codec-parser/src/codecs/mpeg/MPEGParser.js","../node_modules/codec-parser/src/codecs/aac/AACHeader.js","../node_modules/codec-parser/src/codecs/aac/AACFrame.js","../node_modules/codec-parser/src/codecs/aac/AACParser.js","../node_modules/codec-parser/src/codecs/flac/FLACFrame.js","../node_modules/codec-parser/src/codecs/flac/FLACHeader.js","../node_modules/codec-parser/src/codecs/flac/FLACParser.js","../node_modules/codec-parser/src/containers/ogg/OggPageHeader.js","../node_modules/codec-parser/src/containers/ogg/OggPage.js","../node_modules/codec-parser/src/codecs/opus/OpusFrame.js","../node_modules/codec-parser/src/codecs/opus/OpusHeader.js","../node_modules/codec-parser/src/codecs/opus/OpusParser.js","../node_modules/codec-parser/src/codecs/vorbis/VorbisFrame.js","../node_modules/codec-parser/src/codecs/vorbis/VorbisHeader.js","../node_modules/codec-parser/src/codecs/vorbis/VorbisParser.js","../node_modules/codec-parser/src/containers/ogg/OggParser.js","../node_modules/codec-parser/src/CodecParser.js","../node_modules/codec-parser/index.js"],"sourcesContent":["const symbol = Symbol;\n\n// prettier-ignore\n/*\n[\n  [\n    \"left, right\",\n    \"left, right, center\",\n    \"left, center, right\",\n    \"center, left, right\",\n    \"center\"\n  ],\n  [\n    \"front left, front right\",\n    \"front left, front right, front center\",\n    \"front left, front center, front right\",\n    \"front center, front left, front right\",\n    \"front center\"\n  ],\n  [\n    \"side left, side right\",\n    \"side left, side right, side center\",\n    \"side left, side center, side right\",\n    \"side center, side left, side right\",\n    \"side center\"\n  ],\n  [\n    \"rear left, rear right\",\n    \"rear left, rear right, rear center\",\n    \"rear left, rear center, rear right\",\n    \"rear center, rear left, rear right\",\n    \"rear center\"\n  ]\n]\n*/\n\nconst mappingJoin = \", \";\n\nexport const channelMappings = (() => {\n  const front = \"front\";\n  const side = \"side\";\n  const rear = \"rear\";\n  const left = \"left\";\n  const center = \"center\";\n  const right = \"right\";\n\n  return [\"\", front + \" \", side + \" \", rear + \" \"].map((x) =>\n    [\n      [left, right],\n      [left, right, center],\n      [left, center, right],\n      [center, left, right],\n      [center],\n    ].flatMap((y) => y.map((z) => x + z).join(mappingJoin)),\n  );\n})();\n\nexport const lfe = \"LFE\";\nexport const monophonic = \"monophonic (mono)\";\nexport const stereo = \"stereo\";\nconst surround = \"surround\";\n\nexport const getChannelMapping = (channelCount, ...mappings) =>\n  `${\n    [\n      monophonic,\n      stereo,\n      `linear ${surround}`,\n      \"quadraphonic\",\n      `5.0 ${surround}`,\n      `5.1 ${surround}`,\n      `6.1 ${surround}`,\n      `7.1 ${surround}`,\n    ][channelCount - 1]\n  } (${mappings.join(mappingJoin)})`;\n\n// prettier-ignore\nexport const vorbisOpusChannelMapping = [\n  monophonic,\n  getChannelMapping(2,channelMappings[0][0]),\n  getChannelMapping(3,channelMappings[0][2]),\n  getChannelMapping(4,channelMappings[1][0],channelMappings[3][0]),\n  getChannelMapping(5,channelMappings[1][2],channelMappings[3][0]),\n  getChannelMapping(6,channelMappings[1][2],channelMappings[3][0],lfe),\n  getChannelMapping(7,channelMappings[1][2],channelMappings[2][0],channelMappings[3][4],lfe),\n  getChannelMapping(8,channelMappings[1][2],channelMappings[2][0],channelMappings[3][0],lfe),\n]\n\n// sampleRates\nexport const rate192000 = 192000;\nexport const rate176400 = 176400;\nexport const rate96000 = 96000;\nexport const rate88200 = 88200;\nexport const rate64000 = 64000;\nexport const rate48000 = 48000;\nexport const rate44100 = 44100;\nexport const rate32000 = 32000;\nexport const rate24000 = 24000;\nexport const rate22050 = 22050;\nexport const rate16000 = 16000;\nexport const rate12000 = 12000;\nexport const rate11025 = 11025;\nexport const rate8000 = 8000;\nexport const rate7350 = 7350;\n\n// header key constants\nexport const absoluteGranulePosition = \"absoluteGranulePosition\";\nexport const bandwidth = \"bandwidth\";\nexport const bitDepth = \"bitDepth\";\nexport const bitrate = \"bitrate\";\nexport const bitrateMaximum = bitrate + \"Maximum\";\nexport const bitrateMinimum = bitrate + \"Minimum\";\nexport const bitrateNominal = bitrate + \"Nominal\";\nexport const buffer = \"buffer\";\nexport const bufferFullness = buffer + \"Fullness\";\nexport const codec = \"codec\";\nexport const codecFrames = codec + \"Frames\";\nexport const coupledStreamCount = \"coupledStreamCount\";\nexport const crc = \"crc\";\nexport const crc16 = crc + \"16\";\nexport const crc32 = crc + \"32\";\nexport const data = \"data\";\nexport const description = \"description\";\nexport const duration = \"duration\";\nexport const emphasis = \"emphasis\";\nexport const hasOpusPadding = \"hasOpusPadding\";\nexport const header = \"header\";\nexport const isContinuedPacket = \"isContinuedPacket\";\nexport const isCopyrighted = \"isCopyrighted\";\nexport const isFirstPage = \"isFirstPage\";\nexport const isHome = \"isHome\";\nexport const isLastPage = \"isLastPage\";\nexport const isOriginal = \"isOriginal\";\nexport const isPrivate = \"isPrivate\";\nexport const isVbr = \"isVbr\";\nexport const layer = \"layer\";\nexport const length = \"length\";\nexport const mode = \"mode\";\nexport const modeExtension = mode + \"Extension\";\nexport const mpeg = \"mpeg\";\nexport const mpegVersion = mpeg + \"Version\";\nexport const numberAACFrames = \"numberAAC\" + \"Frames\";\nexport const outputGain = \"outputGain\";\nexport const preSkip = \"preSkip\";\nexport const profile = \"profile\";\nexport const profileBits = symbol();\nexport const protection = \"protection\";\nexport const rawData = \"rawData\";\nexport const segments = \"segments\";\nexport const subarray = \"subarray\";\nexport const version = \"version\";\nexport const vorbis = \"vorbis\";\nexport const vorbisComments = vorbis + \"Comments\";\nexport const vorbisSetup = vorbis + \"Setup\";\n\nconst block = \"block\";\nexport const blockingStrategy = block + \"ingStrategy\";\nexport const blockingStrategyBits = symbol();\nexport const blockSize = block + \"Size\";\nexport const blocksize0 = block + \"size0\";\nexport const blocksize1 = block + \"size1\";\nexport const blockSizeBits = symbol();\n\nconst channel = \"channel\";\nexport const channelMappingFamily = channel + \"MappingFamily\";\nexport const channelMappingTable = channel + \"MappingTable\";\nexport const channelMode = channel + \"Mode\";\nexport const channelModeBits = symbol();\nexport const channels = channel + \"s\";\n\nconst copyright = \"copyright\";\nexport const copyrightId = copyright + \"Id\";\nexport const copyrightIdStart = copyright + \"IdStart\";\n\nexport const frame = \"frame\";\nexport const frameCount = frame + \"Count\";\nexport const frameLength = frame + \"Length\";\n\nconst Number = \"Number\";\nexport const frameNumber = frame + Number;\nexport const framePadding = frame + \"Padding\";\nexport const frameSize = frame + \"Size\";\n\nconst Rate = \"Rate\";\nexport const inputSampleRate = \"inputSample\" + Rate;\n\nconst page = \"page\";\nexport const pageChecksum = page + \"Checksum\";\nexport const pageSegmentBytes = symbol();\nexport const pageSegmentTable = page + \"SegmentTable\";\nexport const pageSequenceNumber = page + \"Sequence\" + Number;\n\nconst sample = \"sample\";\nexport const sampleNumber = sample + Number;\nexport const sampleRate = sample + Rate;\nexport const sampleRateBits = symbol();\nexport const samples = sample + \"s\";\n\nconst stream = \"stream\";\nexport const streamCount = stream + \"Count\";\nexport const streamInfo = stream + \"Info\";\nexport const streamSerialNumber = stream + \"Serial\" + Number;\nexport const streamStructureVersion = stream + \"StructureVersion\";\n\nconst total = \"total\";\nexport const totalBytesOut = total + \"BytesOut\";\nexport const totalDuration = total + \"Duration\";\nexport const totalSamples = total + \"Samples\";\n\n// private methods\nexport const readRawData = symbol();\nexport const incrementRawData = symbol();\nexport const mapCodecFrameStats = symbol();\nexport const mapFrameStats = symbol();\nexport const logWarning = symbol();\nexport const logError = symbol();\nexport const syncFrame = symbol();\nexport const fixedLengthFrameSync = symbol();\nexport const getHeader = symbol();\nexport const setHeader = symbol();\nexport const getFrame = symbol();\nexport const parseFrame = symbol();\nexport const parseOggPage = symbol();\nexport const checkCodecUpdate = symbol();\nexport const reset = symbol();\nexport const enable = symbol();\nexport const getHeaderFromUint8Array = symbol();\nexport const checkFrameFooterCrc16 = symbol();\n\nexport const uint8Array = Uint8Array;\nexport const dataView = DataView;\n\nexport const reserved = \"reserved\";\nexport const bad = \"bad\";\nexport const free = \"free\";\nexport const none = \"none\";\nexport const sixteenBitCRC = \"16bit CRC\";\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { length, uint8Array } from \"./constants.js\";\n\nconst getCrcTable = (crcTable, crcInitialValueFunction, crcFunction) => {\n  for (let byte = 0; byte < crcTable[length]; byte++) {\n    let crc = crcInitialValueFunction(byte);\n\n    for (let bit = 8; bit > 0; bit--) crc = crcFunction(crc);\n\n    crcTable[byte] = crc;\n  }\n  return crcTable;\n};\n\nconst crc8Table = getCrcTable(\n  new uint8Array(256),\n  (b) => b,\n  (crc) => (crc & 0x80 ? 0x07 ^ (crc << 1) : crc << 1),\n);\n\nconst flacCrc16Table = [\n  getCrcTable(\n    new Uint16Array(256),\n    (b) => b << 8,\n    (crc) => (crc << 1) ^ (crc & (1 << 15) ? 0x8005 : 0),\n  ),\n];\n\nconst crc32Table = [\n  getCrcTable(\n    new Uint32Array(256),\n    (b) => b,\n    (crc) => (crc >>> 1) ^ ((crc & 1) * 0xedb88320),\n  ),\n];\n\n// build crc tables\nfor (let i = 0; i < 15; i++) {\n  flacCrc16Table.push(new Uint16Array(256));\n  crc32Table.push(new Uint32Array(256));\n\n  for (let j = 0; j <= 0xff; j++) {\n    flacCrc16Table[i + 1][j] =\n      flacCrc16Table[0][flacCrc16Table[i][j] >>> 8] ^\n      (flacCrc16Table[i][j] << 8);\n\n    crc32Table[i + 1][j] =\n      (crc32Table[i][j] >>> 8) ^ crc32Table[0][crc32Table[i][j] & 0xff];\n  }\n}\n\nconst crc8 = (data) => {\n  let crc = 0;\n  const dataLength = data[length];\n\n  for (let i = 0; i !== dataLength; i++) crc = crc8Table[crc ^ data[i]];\n\n  return crc;\n};\n\nconst flacCrc16 = (data) => {\n  const dataLength = data[length];\n  const crcChunkSize = dataLength - 16;\n  let crc = 0;\n  let i = 0;\n\n  while (i <= crcChunkSize) {\n    crc ^= (data[i++] << 8) | data[i++];\n    crc =\n      flacCrc16Table[15][crc >> 8] ^\n      flacCrc16Table[14][crc & 0xff] ^\n      flacCrc16Table[13][data[i++]] ^\n      flacCrc16Table[12][data[i++]] ^\n      flacCrc16Table[11][data[i++]] ^\n      flacCrc16Table[10][data[i++]] ^\n      flacCrc16Table[9][data[i++]] ^\n      flacCrc16Table[8][data[i++]] ^\n      flacCrc16Table[7][data[i++]] ^\n      flacCrc16Table[6][data[i++]] ^\n      flacCrc16Table[5][data[i++]] ^\n      flacCrc16Table[4][data[i++]] ^\n      flacCrc16Table[3][data[i++]] ^\n      flacCrc16Table[2][data[i++]] ^\n      flacCrc16Table[1][data[i++]] ^\n      flacCrc16Table[0][data[i++]];\n  }\n\n  while (i !== dataLength)\n    crc = ((crc & 0xff) << 8) ^ flacCrc16Table[0][(crc >> 8) ^ data[i++]];\n\n  return crc;\n};\n\nconst crc32Function = (data) => {\n  const dataLength = data[length];\n  const crcChunkSize = dataLength - 16;\n  let crc = 0;\n  let i = 0;\n\n  while (i <= crcChunkSize)\n    crc =\n      crc32Table[15][(data[i++] ^ crc) & 0xff] ^\n      crc32Table[14][(data[i++] ^ (crc >>> 8)) & 0xff] ^\n      crc32Table[13][(data[i++] ^ (crc >>> 16)) & 0xff] ^\n      crc32Table[12][data[i++] ^ (crc >>> 24)] ^\n      crc32Table[11][data[i++]] ^\n      crc32Table[10][data[i++]] ^\n      crc32Table[9][data[i++]] ^\n      crc32Table[8][data[i++]] ^\n      crc32Table[7][data[i++]] ^\n      crc32Table[6][data[i++]] ^\n      crc32Table[5][data[i++]] ^\n      crc32Table[4][data[i++]] ^\n      crc32Table[3][data[i++]] ^\n      crc32Table[2][data[i++]] ^\n      crc32Table[1][data[i++]] ^\n      crc32Table[0][data[i++]];\n\n  while (i !== dataLength)\n    crc = crc32Table[0][(crc ^ data[i++]) & 0xff] ^ (crc >>> 8);\n\n  return crc ^ -1;\n};\n\nconst concatBuffers = (...buffers) => {\n  const buffer = new uint8Array(\n    buffers.reduce((acc, buf) => acc + buf[length], 0),\n  );\n\n  buffers.reduce((offset, buf) => {\n    buffer.set(buf, offset);\n    return offset + buf[length];\n  }, 0);\n\n  return buffer;\n};\n\nconst bytesToString = (bytes) => String.fromCharCode(...bytes);\n\n// prettier-ignore\nconst reverseTable = [0x0,0x8,0x4,0xc,0x2,0xa,0x6,0xe,0x1,0x9,0x5,0xd,0x3,0xb,0x7,0xf];\nconst reverse = (val) =>\n  (reverseTable[val & 0b1111] << 4) | reverseTable[val >> 4];\n\nclass BitReader {\n  constructor(data) {\n    this._data = data;\n    this._pos = data[length] * 8;\n  }\n\n  set position(position) {\n    this._pos = position;\n  }\n\n  get position() {\n    return this._pos;\n  }\n\n  read(bits) {\n    const byte = Math.floor(this._pos / 8);\n    const bit = this._pos % 8;\n    this._pos -= bits;\n\n    const window =\n      (reverse(this._data[byte - 1]) << 8) + reverse(this._data[byte]);\n\n    return (window >> (7 - bit)) & 0xff;\n  }\n}\n\n/**\n * @todo Old versions of Safari do not support BigInt\n */\nconst readInt64le = (view, offset) => {\n  try {\n    return view.getBigInt64(offset, true);\n  } catch {\n    const sign = view.getUint8(offset + 7) & 0x80 ? -1 : 1;\n    let firstPart = view.getUint32(offset, true);\n    let secondPart = view.getUint32(offset + 4, true);\n\n    if (sign === -1) {\n      firstPart = ~firstPart + 1;\n      secondPart = ~secondPart + 1;\n    }\n\n    if (secondPart > 0x000fffff) {\n      console.warn(\"This platform does not support BigInt\");\n    }\n\n    return sign * (firstPart + secondPart * 2 ** 32);\n  }\n};\n\nexport {\n  crc8,\n  flacCrc16,\n  crc32Function,\n  reverse,\n  concatBuffers,\n  bytesToString,\n  readInt64le,\n  BitReader,\n};\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport {\n  getHeader,\n  setHeader,\n  checkCodecUpdate,\n  reset,\n  enable,\n} from \"../constants.js\";\n\nexport default class HeaderCache {\n  constructor(onCodecHeader, onCodecUpdate) {\n    this._onCodecHeader = onCodecHeader;\n    this._onCodecUpdate = onCodecUpdate;\n    this[reset]();\n  }\n\n  [enable]() {\n    this._isEnabled = true;\n  }\n\n  [reset]() {\n    this._headerCache = new Map();\n    this._codecUpdateData = new WeakMap();\n    this._codecHeaderSent = false;\n    this._codecShouldUpdate = false;\n    this._bitrate = null;\n    this._isEnabled = false;\n  }\n\n  [checkCodecUpdate](bitrate, totalDuration) {\n    if (this._onCodecUpdate) {\n      if (this._bitrate !== bitrate) {\n        this._bitrate = bitrate;\n        this._codecShouldUpdate = true;\n      }\n\n      // only update if codec data is available\n      const codecData = this._codecUpdateData.get(\n        this._headerCache.get(this._currentHeader),\n      );\n\n      if (this._codecShouldUpdate && codecData) {\n        this._onCodecUpdate(\n          {\n            bitrate,\n            ...codecData,\n          },\n          totalDuration,\n        );\n      }\n\n      this._codecShouldUpdate = false;\n    }\n  }\n\n  [getHeader](key) {\n    const header = this._headerCache.get(key);\n\n    if (header) {\n      this._updateCurrentHeader(key);\n    }\n\n    return header;\n  }\n\n  [setHeader](key, header, codecUpdateFields) {\n    if (this._isEnabled) {\n      if (!this._codecHeaderSent) {\n        this._onCodecHeader({ ...header });\n        this._codecHeaderSent = true;\n      }\n      this._updateCurrentHeader(key);\n\n      this._headerCache.set(key, header);\n      this._codecUpdateData.set(header, codecUpdateFields);\n    }\n  }\n\n  _updateCurrentHeader(key) {\n    if (this._onCodecUpdate && key !== this._currentHeader) {\n      this._codecShouldUpdate = true;\n      this._currentHeader = key;\n    }\n  }\n}\n","export const headerStore = new WeakMap();\nexport const frameStore = new WeakMap();\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../globals.js\";\nimport {\n  frame,\n  length,\n  incrementRawData,\n  mapFrameStats,\n  logWarning,\n  syncFrame,\n  fixedLengthFrameSync,\n  getFrame,\n  getHeader,\n  reset,\n  enable,\n} from \"../constants.js\";\n\n/**\n * @abstract\n * @description Abstract class containing methods for parsing codec frames\n */\nexport default class Parser {\n  constructor(codecParser, headerCache) {\n    this._codecParser = codecParser;\n    this._headerCache = headerCache;\n  }\n\n  *[syncFrame]() {\n    let frameData;\n\n    do {\n      frameData = yield* this.Frame[getFrame](\n        this._codecParser,\n        this._headerCache,\n        0,\n      );\n      if (frameData) return frameData;\n      this._codecParser[incrementRawData](1); // increment to continue syncing\n    } while (true);\n  }\n\n  /**\n   * @description Searches for Frames within bytes containing a sequence of known codec frames.\n   * @param {boolean} ignoreNextFrame Set to true to return frames even if the next frame may not exist at the expected location\n   * @returns {Frame}\n   */\n  *[fixedLengthFrameSync](ignoreNextFrame) {\n    let frameData = yield* this[syncFrame]();\n    const frameLength = frameStore.get(frameData)[length];\n\n    if (\n      ignoreNextFrame ||\n      this._codecParser._flushing ||\n      // check if there is a frame right after this one\n      (yield* this.Header[getHeader](\n        this._codecParser,\n        this._headerCache,\n        frameLength,\n      ))\n    ) {\n      this._headerCache[enable](); // start caching when synced\n\n      this._codecParser[incrementRawData](frameLength); // increment to the next frame\n      this._codecParser[mapFrameStats](frameData);\n      return frameData;\n    }\n\n    this._codecParser[logWarning](\n      `Missing ${frame} at ${frameLength} bytes from current position.`,\n      `Dropping current ${frame} and trying again.`,\n    );\n    this._headerCache[reset](); // frame is invalid and must re-sync and clear cache\n    this._codecParser[incrementRawData](1); // increment to invalidate the current frame\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../globals.js\";\nimport { data, header } from \"../constants.js\";\n\n/**\n * @abstract\n */\nexport default class Frame {\n  constructor(headerValue, dataValue) {\n    frameStore.set(this, { [header]: headerValue });\n\n    this[data] = dataValue;\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore, headerStore } from \"../globals.js\";\nimport {\n  sampleRate,\n  length,\n  frameNumber,\n  header,\n  samples,\n  duration,\n  totalBytesOut,\n  totalSamples,\n  totalDuration,\n  frameLength,\n  subarray,\n  readRawData,\n  getFrame,\n  getHeader,\n} from \"../constants.js\";\nimport Frame from \"../containers/Frame.js\";\n\nexport default class CodecFrame extends Frame {\n  static *[getFrame](Header, Frame, codecParser, headerCache, readOffset) {\n    const headerValue = yield* Header[getHeader](\n      codecParser,\n      headerCache,\n      readOffset,\n    );\n\n    if (headerValue) {\n      const frameLengthValue = headerStore.get(headerValue)[frameLength];\n      const samplesValue = headerStore.get(headerValue)[samples];\n\n      const frame = (yield* codecParser[readRawData](\n        frameLengthValue,\n        readOffset,\n      ))[subarray](0, frameLengthValue);\n\n      return new Frame(headerValue, frame, samplesValue);\n    } else {\n      return null;\n    }\n  }\n\n  constructor(headerValue, dataValue, samplesValue) {\n    super(headerValue, dataValue);\n\n    this[header] = headerValue;\n    this[samples] = samplesValue;\n    this[duration] = (samplesValue / headerValue[sampleRate]) * 1000;\n    this[frameNumber] = null;\n    this[totalBytesOut] = null;\n    this[totalSamples] = null;\n    this[totalDuration] = null;\n\n    frameStore.get(this)[length] = dataValue[length];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n// https://id3.org/Developer%20Information\n\nimport { length, version, readRawData } from \"../constants.js\";\n\nconst unsynchronizationFlag = \"unsynchronizationFlag\";\nconst extendedHeaderFlag = \"extendedHeaderFlag\";\nconst experimentalFlag = \"experimentalFlag\";\nconst footerPresent = \"footerPresent\";\n\nexport default class ID3v2 {\n  static *getID3v2Header(codecParser, headerCache, readOffset) {\n    const headerLength = 10;\n    const header = {};\n\n    let data = yield* codecParser[readRawData](3, readOffset);\n    // Byte (0-2 of 9)\n    // ID3\n    if (data[0] !== 0x49 || data[1] !== 0x44 || data[2] !== 0x33) return null;\n\n    data = yield* codecParser[readRawData](headerLength, readOffset);\n\n    // Byte (3-4 of 9)\n    // * `BBBBBBBB|........`: Major version\n    // * `........|BBBBBBBB`: Minor version\n    header[version] = `id3v2.${data[3]}.${data[4]}`;\n\n    // Byte (5 of 9)\n    // * `....0000.: Zeros (flags not implemented yet)\n    if (data[5] & 0b00001111) return null;\n\n    // Byte (5 of 9)\n    // * `CDEF0000`: Flags\n    // * `C.......`: Unsynchronisation (indicates whether or not unsynchronisation is used)\n    // * `.D......`: Extended header (indicates whether or not the header is followed by an extended header)\n    // * `..E.....`: Experimental indicator (indicates whether or not the tag is in an experimental stage)\n    // * `...F....`: Footer present (indicates that a footer is present at the very end of the tag)\n    header[unsynchronizationFlag] = !!(data[5] & 0b10000000);\n    header[extendedHeaderFlag] = !!(data[5] & 0b01000000);\n    header[experimentalFlag] = !!(data[5] & 0b00100000);\n    header[footerPresent] = !!(data[5] & 0b00010000);\n\n    // Byte (6-9 of 9)\n    // * `0.......|0.......|0.......|0.......`: Zeros\n    if (\n      data[6] & 0b10000000 ||\n      data[7] & 0b10000000 ||\n      data[8] & 0b10000000 ||\n      data[9] & 0b10000000\n    )\n      return null;\n\n    // Byte (6-9 of 9)\n    // * `.FFFFFFF|.FFFFFFF|.FFFFFFF|.FFFFFFF`: Tag Length\n    // The ID3v2 tag size is encoded with four bytes where the most significant bit (bit 7)\n    // is set to zero in every byte, making a total of 28 bits. The zeroed bits are ignored,\n    // so a 257 bytes long tag is represented as $00 00 02 01.\n    const dataLength =\n      (data[6] << 21) | (data[7] << 14) | (data[8] << 7) | data[9];\n\n    header[length] = headerLength + dataLength;\n\n    return new ID3v2(header);\n  }\n\n  constructor(header) {\n    this[version] = header[version];\n    this[unsynchronizationFlag] = header[unsynchronizationFlag];\n    this[extendedHeaderFlag] = header[extendedHeaderFlag];\n    this[experimentalFlag] = header[experimentalFlag];\n    this[footerPresent] = header[footerPresent];\n    this[length] = header[length];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { headerStore } from \"../globals.js\";\nimport {\n  bitDepth,\n  channelMode,\n  sampleRate,\n  bitrate,\n  channels,\n} from \"../constants.js\";\n\nexport default class CodecHeader {\n  /**\n   * @private\n   */\n  constructor(header) {\n    headerStore.set(this, header);\n\n    this[bitDepth] = header[bitDepth];\n    this[bitrate] = null; // set during frame mapping\n    this[channels] = header[channels];\n    this[channelMode] = header[channelMode];\n    this[sampleRate] = header[sampleRate];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport {\n  reserved,\n  bad,\n  free,\n  none,\n  sixteenBitCRC,\n  rate44100,\n  rate48000,\n  rate32000,\n  rate22050,\n  rate24000,\n  rate16000,\n  rate11025,\n  rate12000,\n  rate8000,\n  monophonic,\n  stereo,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  bitrate,\n  channels,\n  isOriginal,\n  isPrivate,\n  layer,\n  length,\n  mpegVersion,\n  frameLength,\n  protection,\n  emphasis,\n  framePadding,\n  isCopyrighted,\n  modeExtension,\n  description,\n  samples,\n  subarray,\n  readRawData,\n  incrementRawData,\n  getHeader,\n  setHeader,\n} from \"../../constants.js\";\nimport { bytesToString } from \"../../utilities.js\";\n\nimport ID3v2 from \"../../metadata/ID3v2.js\";\nimport CodecHeader from \"../CodecHeader.js\";\n\n// http://www.mp3-tech.org/programmer/frame_header.html\n\nconst bitrateMatrix = {\n  // bits | V1,L1 | V1,L2 | V1,L3 | V2,L1 | V2,L2 & L3\n  0b00000000: [free, free, free, free, free],\n  0b00010000: [32, 32, 32, 32, 8],\n  // 0b00100000: [64,   48,  40,  48,  16,],\n  // 0b00110000: [96,   56,  48,  56,  24,],\n  // 0b01000000: [128,  64,  56,  64,  32,],\n  // 0b01010000: [160,  80,  64,  80,  40,],\n  // 0b01100000: [192,  96,  80,  96,  48,],\n  // 0b01110000: [224, 112,  96, 112,  56,],\n  // 0b10000000: [256, 128, 112, 128,  64,],\n  // 0b10010000: [288, 160, 128, 144,  80,],\n  // 0b10100000: [320, 192, 160, 160,  96,],\n  // 0b10110000: [352, 224, 192, 176, 112,],\n  // 0b11000000: [384, 256, 224, 192, 128,],\n  // 0b11010000: [416, 320, 256, 224, 144,],\n  // 0b11100000: [448, 384, 320, 256, 160,],\n  0b11110000: [bad, bad, bad, bad, bad],\n};\n\nconst calcBitrate = (idx, interval, intervalOffset) =>\n  8 *\n    (((idx + intervalOffset) % interval) + interval) *\n    (1 << ((idx + intervalOffset) / interval)) -\n  8 * interval * ((interval / 8) | 0);\n\n// generate bitrate matrix\nfor (let i = 2; i < 15; i++)\n  bitrateMatrix[i << 4] = [\n    i * 32, //                V1,L1\n    calcBitrate(i, 4, 0), //  V1,L2\n    calcBitrate(i, 4, -1), // V1,L3\n    calcBitrate(i, 8, 4), //  V2,L1\n    calcBitrate(i, 8, 0), //  V2,L2 & L3\n  ];\n\nconst v1Layer1 = 0;\nconst v1Layer2 = 1;\nconst v1Layer3 = 2;\nconst v2Layer1 = 3;\nconst v2Layer23 = 4;\n\nconst bands = \"bands \";\nconst to31 = \" to 31\";\nconst layer12ModeExtensions = {\n  0b00000000: bands + 4 + to31,\n  0b00010000: bands + 8 + to31,\n  0b00100000: bands + 12 + to31,\n  0b00110000: bands + 16 + to31,\n};\n\nconst bitrateIndex = \"bitrateIndex\";\nconst v2 = \"v2\";\nconst v1 = \"v1\";\n\nconst intensityStereo = \"Intensity stereo \";\nconst msStereo = \", MS stereo \";\nconst on = \"on\";\nconst off = \"off\";\nconst layer3ModeExtensions = {\n  0b00000000: intensityStereo + off + msStereo + off,\n  0b00010000: intensityStereo + on + msStereo + off,\n  0b00100000: intensityStereo + off + msStereo + on,\n  0b00110000: intensityStereo + on + msStereo + on,\n};\n\nconst layersValues = {\n  0b00000000: { [description]: reserved },\n  0b00000010: {\n    [description]: \"Layer III\",\n    [framePadding]: 1,\n    [modeExtension]: layer3ModeExtensions,\n    [v1]: {\n      [bitrateIndex]: v1Layer3,\n      [samples]: 1152,\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer23,\n      [samples]: 576,\n    },\n  },\n  0b00000100: {\n    [description]: \"Layer II\",\n    [framePadding]: 1,\n    [modeExtension]: layer12ModeExtensions,\n    [samples]: 1152,\n    [v1]: {\n      [bitrateIndex]: v1Layer2,\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer23,\n    },\n  },\n  0b00000110: {\n    [description]: \"Layer I\",\n    [framePadding]: 4,\n    [modeExtension]: layer12ModeExtensions,\n    [samples]: 384,\n    [v1]: {\n      [bitrateIndex]: v1Layer1,\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer1,\n    },\n  },\n};\n\nconst mpegVersionDescription = \"MPEG Version \";\nconst isoIec = \"ISO/IEC \";\nconst mpegVersions = {\n  0b00000000: {\n    [description]: `${mpegVersionDescription}2.5 (later extension of MPEG 2)`,\n    [layer]: v2,\n    [sampleRate]: {\n      0b00000000: rate11025,\n      0b00000100: rate12000,\n      0b00001000: rate8000,\n      0b00001100: reserved,\n    },\n  },\n  0b00001000: { [description]: reserved },\n  0b00010000: {\n    [description]: `${mpegVersionDescription}2 (${isoIec}13818-3)`,\n    [layer]: v2,\n    [sampleRate]: {\n      0b00000000: rate22050,\n      0b00000100: rate24000,\n      0b00001000: rate16000,\n      0b00001100: reserved,\n    },\n  },\n  0b00011000: {\n    [description]: `${mpegVersionDescription}1 (${isoIec}11172-3)`,\n    [layer]: v1,\n    [sampleRate]: {\n      0b00000000: rate44100,\n      0b00000100: rate48000,\n      0b00001000: rate32000,\n      0b00001100: reserved,\n    },\n  },\n  length,\n};\n\nconst protectionValues = {\n  0b00000000: sixteenBitCRC,\n  0b00000001: none,\n};\n\nconst emphasisValues = {\n  0b00000000: none,\n  0b00000001: \"50/15 ms\",\n  0b00000010: reserved,\n  0b00000011: \"CCIT J.17\",\n};\n\nconst channelModes = {\n  0b00000000: { [channels]: 2, [description]: stereo },\n  0b01000000: { [channels]: 2, [description]: \"joint \" + stereo },\n  0b10000000: { [channels]: 2, [description]: \"dual channel\" },\n  0b11000000: { [channels]: 1, [description]: monophonic },\n};\n\nexport default class MPEGHeader extends CodecHeader {\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    const header = {};\n\n    // check for id3 header\n    const id3v2Header = yield* ID3v2.getID3v2Header(\n      codecParser,\n      headerCache,\n      readOffset,\n    );\n\n    if (id3v2Header) {\n      // throw away the data. id3 parsing is not implemented yet.\n      yield* codecParser[readRawData](id3v2Header[length], readOffset);\n      codecParser[incrementRawData](id3v2Header[length]);\n    }\n\n    // Must be at least four bytes.\n    const data = yield* codecParser[readRawData](4, readOffset);\n\n    // Check header cache\n    const key = bytesToString(data[subarray](0, 4));\n    const cachedHeader = headerCache[getHeader](key);\n    if (cachedHeader) return new MPEGHeader(cachedHeader);\n\n    // Frame sync (all bits must be set): `11111111|111`:\n    if (data[0] !== 0xff || data[1] < 0xe0) return null;\n\n    // Byte (2 of 4)\n    // * `111BBCCD`\n    // * `...BB...`: MPEG Audio version ID\n    // * `.....CC.`: Layer description\n    // * `.......D`: Protection bit (0 - Protected by CRC (16bit CRC follows header), 1 = Not protected)\n\n    // Mpeg version (1, 2, 2.5)\n    const mpegVersionValues = mpegVersions[data[1] & 0b00011000];\n    if (mpegVersionValues[description] === reserved) return null;\n\n    // Layer (I, II, III)\n    const layerBits = data[1] & 0b00000110;\n    if (layersValues[layerBits][description] === reserved) return null;\n    const layerValues = {\n      ...layersValues[layerBits],\n      ...layersValues[layerBits][mpegVersionValues[layer]],\n    };\n\n    header[mpegVersion] = mpegVersionValues[description];\n    header[layer] = layerValues[description];\n    header[samples] = layerValues[samples];\n    header[protection] = protectionValues[data[1] & 0b00000001];\n\n    header[length] = 4;\n\n    // Byte (3 of 4)\n    // * `EEEEFFGH`\n    // * `EEEE....`: Bitrate index. 1111 is invalid, everything else is accepted\n    // * `....FF..`: Sample rate\n    // * `......G.`: Padding bit, 0=frame not padded, 1=frame padded\n    // * `.......H`: Private bit.\n    header[bitrate] =\n      bitrateMatrix[data[2] & 0b11110000][layerValues[bitrateIndex]];\n    if (header[bitrate] === bad) return null;\n\n    header[sampleRate] = mpegVersionValues[sampleRate][data[2] & 0b00001100];\n    if (header[sampleRate] === reserved) return null;\n\n    header[framePadding] = data[2] & 0b00000010 && layerValues[framePadding];\n    header[isPrivate] = !!(data[2] & 0b00000001);\n\n    header[frameLength] = Math.floor(\n      (125 * header[bitrate] * header[samples]) / header[sampleRate] +\n        header[framePadding],\n    );\n    if (!header[frameLength]) return null;\n\n    // Byte (4 of 4)\n    // * `IIJJKLMM`\n    // * `II......`: Channel mode\n    // * `..JJ....`: Mode extension (only if joint stereo)\n    // * `....K...`: Copyright\n    // * `.....L..`: Original\n    // * `......MM`: Emphasis\n    const channelModeBits = data[3] & 0b11000000;\n    header[channelMode] = channelModes[channelModeBits][description];\n    header[channels] = channelModes[channelModeBits][channels];\n\n    header[modeExtension] = layerValues[modeExtension][data[3] & 0b00110000];\n    header[isCopyrighted] = !!(data[3] & 0b00001000);\n    header[isOriginal] = !!(data[3] & 0b00000100);\n\n    header[emphasis] = emphasisValues[data[3] & 0b00000011];\n    if (header[emphasis] === reserved) return null;\n\n    header[bitDepth] = 16;\n\n    // set header cache\n    {\n      const { length, frameLength, samples, ...codecUpdateFields } = header;\n\n      headerCache[setHeader](key, header, codecUpdateFields);\n    }\n    return new MPEGHeader(header);\n  }\n\n  /**\n   * @private\n   * Call MPEGHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[bitrate] = header[bitrate];\n    this[emphasis] = header[emphasis];\n    this[framePadding] = header[framePadding];\n    this[isCopyrighted] = header[isCopyrighted];\n    this[isOriginal] = header[isOriginal];\n    this[isPrivate] = header[isPrivate];\n    this[layer] = header[layer];\n    this[modeExtension] = header[modeExtension];\n    this[mpegVersion] = header[mpegVersion];\n    this[protection] = header[protection];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { getFrame } from \"../../constants.js\";\n\nimport CodecFrame from \"../CodecFrame.js\";\nimport MPEGHeader from \"./MPEGHeader.js\";\n\nexport default class MPEGFrame extends CodecFrame {\n  static *[getFrame](codecParser, headerCache, readOffset) {\n    return yield* super[getFrame](\n      MPEGHeader,\n      MPEGFrame,\n      codecParser,\n      headerCache,\n      readOffset,\n    );\n  }\n\n  constructor(header, frame, samples) {\n    super(header, frame, samples);\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport {\n  codec,\n  mpeg,\n  fixedLengthFrameSync,\n  parseFrame,\n} from \"../../constants.js\";\n\nimport Parser from \"../Parser.js\";\nimport MPEGFrame from \"./MPEGFrame.js\";\nimport MPEGHeader from \"./MPEGHeader.js\";\n\nexport default class MPEGParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = MPEGFrame;\n    this.Header = MPEGHeader;\n\n    onCodec(this[codec]);\n  }\n\n  get [codec]() {\n    return mpeg;\n  }\n\n  *[parseFrame]() {\n    return yield* this[fixedLengthFrameSync]();\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\nhttps://wiki.multimedia.cx/index.php/ADTS\n\nAAAAAAAA AAAABCCD EEFFFFGH HHIJKLMM MMMMMMMM MMMOOOOO OOOOOOPP (QQQQQQQQ QQQQQQQQ)\n\nAACHeader consists of 7 or 9 bytes (without or with CRC).\nLetter  Length (bits)  Description\nA  12  syncword 0xFFF, all bits must be 1\nB  1   MPEG Version: 0 for MPEG-4, 1 for MPEG-2\nC  2   Layer: always 0\nD  1   protection absent, Warning, set to 1 if there is no CRC and 0 if there is CRC\nE  2   profile, the MPEG-4 Audio Object Type minus 1\nF  4   MPEG-4 Sampling Frequency Index (15 is forbidden)\nG  1   private bit, guaranteed never to be used by MPEG, set to 0 when encoding, ignore when decoding\nH  3   MPEG-4 Channel Configuration (in the case of 0, the channel configuration is sent via an inband PCE)\nI  1   originality, set to 0 when encoding, ignore when decoding\nJ  1   home, set to 0 when encoding, ignore when decoding\nK  1   copyrighted id bit, the next bit of a centrally registered copyright identifier, set to 0 when encoding, ignore when decoding\nL  1   copyright id start, signals that this frame's copyright id bit is the first bit of the copyright id, set to 0 when encoding, ignore when decoding\nM  13  frame length, this value must include 7 or 9 bytes of header length: FrameLength = (ProtectionAbsent == 1 ? 7 : 9) + size(AACFrame)\nO  11  Buffer fullness // 0x7FF for VBR\nP  2   Number of AAC frames (RDBs) in ADTS frame minus 1, for maximum compatibility always use 1 AAC frame per ADTS frame\nQ  16  CRC if protection absent is 0 \n*/\n\nimport { headerStore } from \"../../globals.js\";\nimport { bytesToString } from \"../../utilities.js\";\nimport {\n  reserved,\n  bad,\n  none,\n  sixteenBitCRC,\n  rate96000,\n  rate88200,\n  rate64000,\n  rate48000,\n  rate44100,\n  rate32000,\n  rate24000,\n  rate22050,\n  rate16000,\n  rate12000,\n  rate11025,\n  rate8000,\n  rate7350,\n  channelMappings,\n  getChannelMapping,\n  monophonic,\n  lfe,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  channels,\n  copyrightId,\n  copyrightIdStart,\n  bufferFullness,\n  isHome,\n  isOriginal,\n  isPrivate,\n  layer,\n  length,\n  mpegVersion,\n  numberAACFrames,\n  profile,\n  protection,\n  frameLength,\n  description,\n  samples,\n  sampleRateBits,\n  profileBits,\n  channelModeBits,\n  buffer,\n  readRawData,\n  getHeader,\n  setHeader,\n  uint8Array,\n  dataView,\n} from \"../../constants.js\";\n\nimport CodecHeader from \"../CodecHeader.js\";\n\nconst mpegVersionValues = {\n  0b00000000: \"MPEG-4\",\n  0b00001000: \"MPEG-2\",\n};\n\nconst layerValues = {\n  0b00000000: \"valid\",\n  0b00000010: bad,\n  0b00000100: bad,\n  0b00000110: bad,\n};\n\nconst protectionValues = {\n  0b00000000: sixteenBitCRC,\n  0b00000001: none,\n};\n\nconst profileValues = {\n  0b00000000: \"AAC Main\",\n  0b01000000: \"AAC LC (Low Complexity)\",\n  0b10000000: \"AAC SSR (Scalable Sample Rate)\",\n  0b11000000: \"AAC LTP (Long Term Prediction)\",\n};\n\nconst sampleRates = {\n  0b00000000: rate96000,\n  0b00000100: rate88200,\n  0b00001000: rate64000,\n  0b00001100: rate48000,\n  0b00010000: rate44100,\n  0b00010100: rate32000,\n  0b00011000: rate24000,\n  0b00011100: rate22050,\n  0b00100000: rate16000,\n  0b00100100: rate12000,\n  0b00101000: rate11025,\n  0b00101100: rate8000,\n  0b00110000: rate7350,\n  0b00110100: reserved,\n  0b00111000: reserved,\n  0b00111100: \"frequency is written explicitly\",\n};\n\n// prettier-ignore\nconst channelModeValues = {\n  0b000000000: { [channels]: 0, [description]: \"Defined in AOT Specific Config\" },\n  /*\n  'monophonic (mono)'\n  'stereo (left, right)'\n  'linear surround (front center, front left, front right)'\n  'quadraphonic (front center, front left, front right, rear center)'\n  '5.0 surround (front center, front left, front right, rear left, rear right)'\n  '5.1 surround (front center, front left, front right, rear left, rear right, LFE)'\n  '7.1 surround (front center, front left, front right, side left, side right, rear left, rear right, LFE)'\n  */\n  0b001000000: { [channels]: 1, [description]: monophonic },\n  0b010000000: { [channels]: 2, [description]: getChannelMapping(2,channelMappings[0][0]) },\n  0b011000000: { [channels]: 3, [description]: getChannelMapping(3,channelMappings[1][3]), },\n  0b100000000: { [channels]: 4, [description]: getChannelMapping(4,channelMappings[1][3],channelMappings[3][4]), },\n  0b101000000: { [channels]: 5, [description]: getChannelMapping(5,channelMappings[1][3],channelMappings[3][0]), },\n  0b110000000: { [channels]: 6, [description]: getChannelMapping(6,channelMappings[1][3],channelMappings[3][0],lfe), },\n  0b111000000: { [channels]: 8, [description]: getChannelMapping(8,channelMappings[1][3],channelMappings[2][0],channelMappings[3][0],lfe), },\n};\n\nexport default class AACHeader extends CodecHeader {\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    const header = {};\n\n    // Must be at least seven bytes. Out of data\n    const data = yield* codecParser[readRawData](7, readOffset);\n\n    // Check header cache\n    const key = bytesToString([\n      data[0],\n      data[1],\n      data[2],\n      (data[3] & 0b11111100) | (data[6] & 0b00000011), // frame length, buffer fullness varies so don't cache it\n    ]);\n    const cachedHeader = headerCache[getHeader](key);\n\n    if (!cachedHeader) {\n      // Frame sync (all bits must be set): `11111111|1111`:\n      if (data[0] !== 0xff || data[1] < 0xf0) return null;\n\n      // Byte (2 of 7)\n      // * `1111BCCD`\n      // * `....B...`: MPEG Version: 0 for MPEG-4, 1 for MPEG-2\n      // * `.....CC.`: Layer: always 0\n      // * `.......D`: protection absent, Warning, set to 1 if there is no CRC and 0 if there is CRC\n      header[mpegVersion] = mpegVersionValues[data[1] & 0b00001000];\n\n      header[layer] = layerValues[data[1] & 0b00000110];\n      if (header[layer] === bad) return null;\n\n      const protectionBit = data[1] & 0b00000001;\n      header[protection] = protectionValues[protectionBit];\n      header[length] = protectionBit ? 7 : 9;\n\n      // Byte (3 of 7)\n      // * `EEFFFFGH`\n      // * `EE......`: profile, the MPEG-4 Audio Object Type minus 1\n      // * `..FFFF..`: MPEG-4 Sampling Frequency Index (15 is forbidden)\n      // * `......G.`: private bit, guaranteed never to be used by MPEG, set to 0 when encoding, ignore when decoding\n      header[profileBits] = data[2] & 0b11000000;\n      header[sampleRateBits] = data[2] & 0b00111100;\n      const privateBit = data[2] & 0b00000010;\n\n      header[profile] = profileValues[header[profileBits]];\n\n      header[sampleRate] = sampleRates[header[sampleRateBits]];\n      if (header[sampleRate] === reserved) return null;\n\n      header[isPrivate] = !!privateBit;\n\n      // Byte (3,4 of 7)\n      // * `.......H|HH......`: MPEG-4 Channel Configuration (in the case of 0, the channel configuration is sent via an inband PCE)\n      header[channelModeBits] = ((data[2] << 8) | data[3]) & 0b111000000;\n      header[channelMode] =\n        channelModeValues[header[channelModeBits]][description];\n      header[channels] = channelModeValues[header[channelModeBits]][channels];\n\n      // Byte (4 of 7)\n      // * `HHIJKLMM`\n      // * `..I.....`: originality, set to 0 when encoding, ignore when decoding\n      // * `...J....`: home, set to 0 when encoding, ignore when decoding\n      // * `....K...`: copyrighted id bit, the next bit of a centrally registered copyright identifier, set to 0 when encoding, ignore when decoding\n      // * `.....L..`: copyright id start, signals that this frame's copyright id bit is the first bit of the copyright id, set to 0 when encoding, ignore when decoding\n      header[isOriginal] = !!(data[3] & 0b00100000);\n      header[isHome] = !!(data[3] & 0b00001000);\n      header[copyrightId] = !!(data[3] & 0b00001000);\n      header[copyrightIdStart] = !!(data[3] & 0b00000100);\n      header[bitDepth] = 16;\n      header[samples] = 1024;\n\n      // Byte (7 of 7)\n      // * `......PP` Number of AAC frames (RDBs) in ADTS frame minus 1, for maximum compatibility always use 1 AAC frame per ADTS frame\n      header[numberAACFrames] = data[6] & 0b00000011;\n\n      {\n        const {\n          length,\n          channelModeBits,\n          profileBits,\n          sampleRateBits,\n          frameLength,\n          samples,\n          numberAACFrames,\n          ...codecUpdateFields\n        } = header;\n        headerCache[setHeader](key, header, codecUpdateFields);\n      }\n    } else {\n      Object.assign(header, cachedHeader);\n    }\n\n    // Byte (4,5,6 of 7)\n    // * `.......MM|MMMMMMMM|MMM.....`: frame length, this value must include 7 or 9 bytes of header length: FrameLength = (ProtectionAbsent == 1 ? 7 : 9) + size(AACFrame)\n    header[frameLength] =\n      ((data[3] << 11) | (data[4] << 3) | (data[5] >> 5)) & 0x1fff;\n    if (!header[frameLength]) return null;\n\n    // Byte (6,7 of 7)\n    // * `...OOOOO|OOOOOO..`: Buffer fullness\n    const bufferFullnessBits = ((data[5] << 6) | (data[6] >> 2)) & 0x7ff;\n    header[bufferFullness] =\n      bufferFullnessBits === 0x7ff ? \"VBR\" : bufferFullnessBits;\n\n    return new AACHeader(header);\n  }\n\n  /**\n   * @private\n   * Call AACHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[copyrightId] = header[copyrightId];\n    this[copyrightIdStart] = header[copyrightIdStart];\n    this[bufferFullness] = header[bufferFullness];\n    this[isHome] = header[isHome];\n    this[isOriginal] = header[isOriginal];\n    this[isPrivate] = header[isPrivate];\n    this[layer] = header[layer];\n    this[length] = header[length];\n    this[mpegVersion] = header[mpegVersion];\n    this[numberAACFrames] = header[numberAACFrames];\n    this[profile] = header[profile];\n    this[protection] = header[protection];\n  }\n\n  get audioSpecificConfig() {\n    // Audio Specific Configuration\n    // * `000EEFFF|F0HHH000`:\n    // * `000EE...|........`: Object Type (profileBit + 1)\n    // * `.....FFF|F.......`: Sample Rate\n    // * `........|.0HHH...`: Channel Configuration\n    // * `........|.....0..`: Frame Length (1024)\n    // * `........|......0.`: does not depend on core coder\n    // * `........|.......0`: Not Extension\n    const header = headerStore.get(this);\n\n    const audioSpecificConfig =\n      ((header[profileBits] + 0x40) << 5) |\n      (header[sampleRateBits] << 5) |\n      (header[channelModeBits] >> 3);\n\n    const bytes = new uint8Array(2);\n    new dataView(bytes[buffer]).setUint16(0, audioSpecificConfig, false);\n    return bytes;\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { getFrame } from \"../../constants.js\";\n\nimport CodecFrame from \"../CodecFrame.js\";\nimport AACHeader from \"./AACHeader.js\";\n\nexport default class AACFrame extends CodecFrame {\n  static *[getFrame](codecParser, headerCache, readOffset) {\n    return yield* super[getFrame](\n      AACHeader,\n      AACFrame,\n      codecParser,\n      headerCache,\n      readOffset,\n    );\n  }\n\n  constructor(header, frame, samples) {\n    super(header, frame, samples);\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { codec, fixedLengthFrameSync, parseFrame } from \"../../constants.js\";\n\nimport Parser from \"../Parser.js\";\nimport AACFrame from \"./AACFrame.js\";\nimport AACHeader from \"./AACHeader.js\";\n\nexport default class AACParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = AACFrame;\n    this.Header = AACHeader;\n\n    onCodec(this[codec]);\n  }\n\n  get [codec]() {\n    return \"aac\";\n  }\n\n  *[parseFrame]() {\n    return yield* this[fixedLengthFrameSync]();\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { headerStore } from \"../../globals.js\";\nimport { flacCrc16 } from \"../../utilities.js\";\nimport {\n  length,\n  streamInfo,\n  crc16,\n  samples,\n  subarray,\n  checkFrameFooterCrc16,\n} from \"../../constants.js\";\nimport CodecFrame from \"../CodecFrame.js\";\n\nexport default class FLACFrame extends CodecFrame {\n  static _getFrameFooterCrc16(data) {\n    return (data[data[length] - 2] << 8) + data[data[length] - 1];\n  }\n\n  // check frame footer crc\n  // https://xiph.org/flac/format.html#frame_footer\n  static [checkFrameFooterCrc16](data) {\n    const expectedCrc16 = FLACFrame._getFrameFooterCrc16(data);\n    const actualCrc16 = flacCrc16(data[subarray](0, -2));\n\n    return expectedCrc16 === actualCrc16;\n  }\n\n  constructor(data, header, streamInfoValue) {\n    header[streamInfo] = streamInfoValue;\n    header[crc16] = FLACFrame._getFrameFooterCrc16(data);\n\n    super(header, data, headerStore.get(header)[samples]);\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\nhttps://xiph.org/flac/format.html\n\nAAAAAAAA AAAAAABC DDDDEEEE FFFFGGGH \n(IIIIIIII...)\n(JJJJJJJJ|JJJJJJJJ)\n(KKKKKKKK|KKKKKKKK)\nLLLLLLLLL\n\nFLAC Frame Header\nLetter  Length (bits)  Description\nA   13  11111111|11111\nB   1   Reserved 0 - mandatory, 1 - reserved\nC   1   Blocking strategy, 0 - fixed, 1 - variable\nD   4   Block size in inter-channel samples\nE   4   Sample rate\nF   4   Channel assignment\nG   3   Sample size in bits\nH   1   Reserved 0 - mandatory, 1 - reserved\nI   ?   if(variable blocksize)\n           <8-56>:\"UTF-8\" coded sample number (decoded number is 36 bits) [4]\n        else\n           <8-48>:\"UTF-8\" coded frame number (decoded number is 31 bits) [4]\nJ   ?   if(blocksize bits == 011x)\n            8/16 bit (blocksize-1)\nK   ?   if(sample rate bits == 11xx)\n            8/16 bit sample rate\nL   8   CRC-8 (polynomial = x^8 + x^2 + x^1 + x^0, initialized with 0) of everything before the crc, including the sync code\n        \n*/\n\nimport {\n  reserved,\n  bad,\n  rate88200,\n  rate176400,\n  rate192000,\n  rate8000,\n  rate16000,\n  rate22050,\n  rate24000,\n  rate32000,\n  rate44100,\n  rate48000,\n  rate96000,\n  channelMappings,\n  getChannelMapping,\n  monophonic,\n  stereo,\n  lfe,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  channels,\n  length,\n  crc16,\n  blockingStrategy,\n  blockSize,\n  frameNumber,\n  sampleNumber,\n  streamInfo,\n  description,\n  samples,\n  sampleRateBits,\n  blockingStrategyBits,\n  blockSizeBits,\n  crc,\n  subarray,\n  readRawData,\n  getHeader,\n  setHeader,\n  getHeaderFromUint8Array,\n} from \"../../constants.js\";\nimport { bytesToString, crc8 } from \"../../utilities.js\";\nimport CodecHeader from \"../CodecHeader.js\";\n\nconst getFromStreamInfo = \"get from STREAMINFO metadata block\";\n\nconst blockingStrategyValues = {\n  0b00000000: \"Fixed\",\n  0b00000001: \"Variable\",\n};\n\nconst blockSizeValues = {\n  0b00000000: reserved,\n  0b00010000: 192,\n  // 0b00100000: 576,\n  // 0b00110000: 1152,\n  // 0b01000000: 2304,\n  // 0b01010000: 4608,\n  // 0b01100000: \"8-bit (blocksize-1) from end of header\",\n  // 0b01110000: \"16-bit (blocksize-1) from end of header\",\n  // 0b10000000: 256,\n  // 0b10010000: 512,\n  // 0b10100000: 1024,\n  // 0b10110000: 2048,\n  // 0b11000000: 4096,\n  // 0b11010000: 8192,\n  // 0b11100000: 16384,\n  // 0b11110000: 32768,\n};\nfor (let i = 2; i < 16; i++)\n  blockSizeValues[i << 4] = i < 6 ? 576 * 2 ** (i - 2) : 2 ** i;\n\nconst sampleRateValues = {\n  0b00000000: getFromStreamInfo,\n  0b00000001: rate88200,\n  0b00000010: rate176400,\n  0b00000011: rate192000,\n  0b00000100: rate8000,\n  0b00000101: rate16000,\n  0b00000110: rate22050,\n  0b00000111: rate24000,\n  0b00001000: rate32000,\n  0b00001001: rate44100,\n  0b00001010: rate48000,\n  0b00001011: rate96000,\n  // 0b00001100: \"8-bit sample rate (in kHz) from end of header\",\n  // 0b00001101: \"16-bit sample rate (in Hz) from end of header\",\n  // 0b00001110: \"16-bit sample rate (in tens of Hz) from end of header\",\n  0b00001111: bad,\n};\n\n/* prettier-ignore */\nconst channelAssignments = {\n  /*'\n  'monophonic (mono)'\n  'stereo (left, right)'\n  'linear surround (left, right, center)'\n  'quadraphonic (front left, front right, rear left, rear right)'\n  '5.0 surround (front left, front right, front center, rear left, rear right)'\n  '5.1 surround (front left, front right, front center, LFE, rear left, rear right)'\n  '6.1 surround (front left, front right, front center, LFE, rear center, side left, side right)'\n  '7.1 surround (front left, front right, front center, LFE, rear left, rear right, side left, side right)'\n  */\n  0b00000000: {[channels]: 1, [description]: monophonic},\n  0b00010000: {[channels]: 2, [description]: getChannelMapping(2,channelMappings[0][0])},\n  0b00100000: {[channels]: 3, [description]: getChannelMapping(3,channelMappings[0][1])},\n  0b00110000: {[channels]: 4, [description]: getChannelMapping(4,channelMappings[1][0],channelMappings[3][0])},\n  0b01000000: {[channels]: 5, [description]: getChannelMapping(5,channelMappings[1][1],channelMappings[3][0])},\n  0b01010000: {[channels]: 6, [description]: getChannelMapping(6,channelMappings[1][1],lfe,channelMappings[3][0])},\n  0b01100000: {[channels]: 7, [description]: getChannelMapping(7,channelMappings[1][1],lfe,channelMappings[3][4],channelMappings[2][0])},\n  0b01110000: {[channels]: 8, [description]: getChannelMapping(8,channelMappings[1][1],lfe,channelMappings[3][0],channelMappings[2][0])},\n  0b10000000: {[channels]: 2, [description]: `${stereo} (left, diff)`},\n  0b10010000: {[channels]: 2, [description]: `${stereo} (diff, right)`},\n  0b10100000: {[channels]: 2, [description]: `${stereo} (avg, diff)`},\n  0b10110000: reserved,\n  0b11000000: reserved,\n  0b11010000: reserved,\n  0b11100000: reserved,\n  0b11110000: reserved,\n}\n\nconst bitDepthValues = {\n  0b00000000: getFromStreamInfo,\n  0b00000010: 8,\n  0b00000100: 12,\n  0b00000110: reserved,\n  0b00001000: 16,\n  0b00001010: 20,\n  0b00001100: 24,\n  0b00001110: reserved,\n};\n\nexport default class FLACHeader extends CodecHeader {\n  // https://datatracker.ietf.org/doc/html/rfc3629#section-3\n  //    Char. number range  |        UTF-8 octet sequence\n  //    (hexadecimal)    |              (binary)\n  // --------------------+---------------------------------------------\n  // 0000 0000-0000 007F | 0xxxxxxx\n  // 0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n  // 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n  // 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n  static _decodeUTF8Int(data) {\n    if (data[0] > 0xfe) {\n      return null; // length byte must have at least one zero as the lsb\n    }\n\n    if (data[0] < 0x80) return { value: data[0], length: 1 };\n\n    // get length by counting the number of msb that are set to 1\n    let length = 1;\n    for (let zeroMask = 0x40; zeroMask & data[0]; zeroMask >>= 1) length++;\n\n    let idx = length - 1,\n      value = 0,\n      shift = 0;\n\n    // sum together the encoded bits in bytes 2 to length\n    // 1110xxxx 10[cccccc] 10[bbbbbb] 10[aaaaaa]\n    //\n    //    value = [cccccc] | [bbbbbb] | [aaaaaa]\n    for (; idx > 0; shift += 6, idx--) {\n      if ((data[idx] & 0xc0) !== 0x80) {\n        return null; // each byte should have leading 10xxxxxx\n      }\n      value |= (data[idx] & 0x3f) << shift; // add the encoded bits\n    }\n\n    // read the final encoded bits in byte 1\n    //     1110[dddd] 10[cccccc] 10[bbbbbb] 10[aaaaaa]\n    //\n    // value = [dddd] | [cccccc] | [bbbbbb] | [aaaaaa]\n    value |= (data[idx] & (0x7f >> length)) << shift;\n\n    return { value, length };\n  }\n\n  static [getHeaderFromUint8Array](data, headerCache) {\n    const codecParserStub = {\n      [readRawData]: function* () {\n        return data;\n      },\n    };\n\n    return FLACHeader[getHeader](codecParserStub, headerCache, 0).next().value;\n  }\n\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    // Must be at least 6 bytes.\n    let data = yield* codecParser[readRawData](6, readOffset);\n\n    // Bytes (1-2 of 6)\n    // * `11111111|111110..`: Frame sync\n    // * `........|......0.`: Reserved 0 - mandatory, 1 - reserved\n    if (data[0] !== 0xff || !(data[1] === 0xf8 || data[1] === 0xf9)) {\n      return null;\n    }\n\n    const header = {};\n\n    // Check header cache\n    const key = bytesToString(data[subarray](0, 4));\n    const cachedHeader = headerCache[getHeader](key);\n\n    if (!cachedHeader) {\n      // Byte (2 of 6)\n      // * `.......C`: Blocking strategy, 0 - fixed, 1 - variable\n      header[blockingStrategyBits] = data[1] & 0b00000001;\n      header[blockingStrategy] =\n        blockingStrategyValues[header[blockingStrategyBits]];\n\n      // Byte (3 of 6)\n      // * `DDDD....`: Block size in inter-channel samples\n      // * `....EEEE`: Sample rate\n      header[blockSizeBits] = data[2] & 0b11110000;\n      header[sampleRateBits] = data[2] & 0b00001111;\n\n      header[blockSize] = blockSizeValues[header[blockSizeBits]];\n      if (header[blockSize] === reserved) {\n        return null;\n      }\n\n      header[sampleRate] = sampleRateValues[header[sampleRateBits]];\n      if (header[sampleRate] === bad) {\n        return null;\n      }\n\n      // Byte (4 of 6)\n      // * `FFFF....`: Channel assignment\n      // * `....GGG.`: Sample size in bits\n      // * `.......H`: Reserved 0 - mandatory, 1 - reserved\n      if (data[3] & 0b00000001) {\n        return null;\n      }\n\n      const channelAssignment = channelAssignments[data[3] & 0b11110000];\n      if (channelAssignment === reserved) {\n        return null;\n      }\n\n      header[channels] = channelAssignment[channels];\n      header[channelMode] = channelAssignment[description];\n\n      header[bitDepth] = bitDepthValues[data[3] & 0b00001110];\n      if (header[bitDepth] === reserved) {\n        return null;\n      }\n    } else {\n      Object.assign(header, cachedHeader);\n    }\n\n    // Byte (5...)\n    // * `IIIIIIII|...`: VBR block size ? sample number : frame number\n    header[length] = 5;\n\n    // check if there is enough data to parse UTF8\n    data = yield* codecParser[readRawData](header[length] + 8, readOffset);\n\n    const decodedUtf8 = FLACHeader._decodeUTF8Int(data[subarray](4));\n    if (!decodedUtf8) {\n      return null;\n    }\n\n    if (header[blockingStrategyBits]) {\n      header[sampleNumber] = decodedUtf8.value;\n    } else {\n      header[frameNumber] = decodedUtf8.value;\n    }\n\n    header[length] += decodedUtf8[length];\n\n    // Byte (...)\n    // * `JJJJJJJJ|(JJJJJJJJ)`: Blocksize (8/16bit custom value)\n    if (header[blockSizeBits] === 0b01100000) {\n      // 8 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[blockSize] = data[header[length] - 1] + 1;\n      header[length] += 1;\n    } else if (header[blockSizeBits] === 0b01110000) {\n      // 16 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[blockSize] =\n        (data[header[length] - 1] << 8) + data[header[length]] + 1;\n      header[length] += 2;\n    }\n\n    header[samples] = header[blockSize];\n\n    // Byte (...)\n    // * `KKKKKKKK|(KKKKKKKK)`: Sample rate (8/16bit custom value)\n    if (header[sampleRateBits] === 0b00001100) {\n      // 8 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[sampleRate] = data[header[length] - 1] * 1000;\n      header[length] += 1;\n    } else if (header[sampleRateBits] === 0b00001101) {\n      // 16 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[sampleRate] =\n        (data[header[length] - 1] << 8) + data[header[length]];\n      header[length] += 2;\n    } else if (header[sampleRateBits] === 0b00001110) {\n      // 16 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[sampleRate] =\n        ((data[header[length] - 1] << 8) + data[header[length]]) * 10;\n      header[length] += 2;\n    }\n\n    // Byte (...)\n    // * `LLLLLLLL`: CRC-8\n    if (data[length] < header[length])\n      data = yield* codecParser[readRawData](header[length], readOffset);\n\n    header[crc] = data[header[length] - 1];\n    if (header[crc] !== crc8(data[subarray](0, header[length] - 1))) {\n      return null;\n    }\n\n    {\n      if (!cachedHeader) {\n        const {\n          blockingStrategyBits,\n          frameNumber,\n          sampleNumber,\n          samples,\n          sampleRateBits,\n          blockSizeBits,\n          crc,\n          length,\n          ...codecUpdateFields\n        } = header;\n        headerCache[setHeader](key, header, codecUpdateFields);\n      }\n    }\n    return new FLACHeader(header);\n  }\n\n  /**\n   * @private\n   * Call FLACHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[crc16] = null; // set in FLACFrame\n    this[blockingStrategy] = header[blockingStrategy];\n    this[blockSize] = header[blockSize];\n    this[frameNumber] = header[frameNumber];\n    this[sampleNumber] = header[sampleNumber];\n    this[streamInfo] = null; // set during ogg parsing\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore, headerStore } from \"../../globals.js\";\nimport {\n  length,\n  pageSequenceNumber,\n  data,\n  codec,\n  codecFrames,\n  segments,\n  subarray,\n  readRawData,\n  incrementRawData,\n  mapFrameStats,\n  logWarning,\n  parseFrame,\n  parseOggPage,\n  getHeader,\n  enable,\n  checkFrameFooterCrc16,\n  getHeaderFromUint8Array,\n} from \"../../constants.js\";\nimport Parser from \"../Parser.js\";\nimport FLACFrame from \"./FLACFrame.js\";\nimport FLACHeader from \"./FLACHeader.js\";\n\nconst MIN_FLAC_FRAME_SIZE = 2;\nconst MAX_FLAC_FRAME_SIZE = 512 * 1024;\n\nexport default class FLACParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = FLACFrame;\n    this.Header = FLACHeader;\n\n    onCodec(this[codec]);\n  }\n\n  get [codec]() {\n    return \"flac\";\n  }\n\n  *_getNextFrameSyncOffset(offset) {\n    const data = yield* this._codecParser[readRawData](2, 0);\n    const dataLength = data[length] - 2;\n\n    while (offset < dataLength) {\n      // * `11111111|111110..`: Frame sync\n      // * `........|......0.`: Reserved 0 - mandatory, 1 - reserved\n      const firstByte = data[offset];\n      if (firstByte === 0xff) {\n        const secondByte = data[offset + 1];\n        if (secondByte === 0xf8 || secondByte === 0xf9) break;\n        if (secondByte !== 0xff) offset++; // might as well check for the next sync byte\n      }\n      offset++;\n    }\n\n    return offset;\n  }\n\n  *[parseFrame]() {\n    // find the first valid frame header\n    do {\n      const header = yield* FLACHeader[getHeader](\n        this._codecParser,\n        this._headerCache,\n        0,\n      );\n\n      if (header) {\n        // found a valid frame header\n        // find the next valid frame header\n        let nextHeaderOffset =\n          headerStore.get(header)[length] + MIN_FLAC_FRAME_SIZE;\n\n        while (nextHeaderOffset <= MAX_FLAC_FRAME_SIZE) {\n          if (\n            this._codecParser._flushing ||\n            (yield* FLACHeader[getHeader](\n              this._codecParser,\n              this._headerCache,\n              nextHeaderOffset,\n            ))\n          ) {\n            // found a valid next frame header\n            let frameData =\n              yield* this._codecParser[readRawData](nextHeaderOffset);\n\n            if (!this._codecParser._flushing)\n              frameData = frameData[subarray](0, nextHeaderOffset);\n\n            // check that this is actually the next header by validating the frame footer crc16\n            if (FLACFrame[checkFrameFooterCrc16](frameData)) {\n              // both frame headers, and frame footer crc16 are valid, we are synced (odds are pretty low of a false positive)\n              const frame = new FLACFrame(frameData, header);\n\n              this._headerCache[enable](); // start caching when synced\n              this._codecParser[incrementRawData](nextHeaderOffset); // increment to the next frame\n              this._codecParser[mapFrameStats](frame);\n\n              return frame;\n            }\n          }\n\n          nextHeaderOffset = yield* this._getNextFrameSyncOffset(\n            nextHeaderOffset + 1,\n          );\n        }\n\n        this._codecParser[logWarning](\n          `Unable to sync FLAC frame after searching ${nextHeaderOffset} bytes.`,\n        );\n        this._codecParser[incrementRawData](nextHeaderOffset);\n      } else {\n        // not synced, increment data to continue syncing\n        this._codecParser[incrementRawData](\n          yield* this._getNextFrameSyncOffset(1),\n        );\n      }\n    } while (true);\n  }\n\n  [parseOggPage](oggPage) {\n    if (oggPage[pageSequenceNumber] === 0) {\n      // Identification header\n\n      this._headerCache[enable]();\n      this._streamInfo = oggPage[data][subarray](13);\n    } else if (oggPage[pageSequenceNumber] === 1) {\n      // Vorbis comments\n    } else {\n      oggPage[codecFrames] = frameStore\n        .get(oggPage)\n        [segments].map((segment) => {\n          const header = FLACHeader[getHeaderFromUint8Array](\n            segment,\n            this._headerCache,\n          );\n\n          if (header) {\n            return new FLACFrame(segment, header, this._streamInfo);\n          } else {\n            this._codecParser[logWarning](\n              \"Failed to parse Ogg FLAC frame\",\n              \"Skipping invalid FLAC frame\",\n            );\n          }\n        })\n        .filter((frame) => !!frame);\n    }\n\n    return oggPage;\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\nhttps://xiph.org/ogg/doc/framing.html\n\nAAAAAAAA AAAAAAAA AAAAAAAA AAAAAAAA BBBBBBBB 00000CDE\n\n(LSB)                                                             (MSB)\nFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF\nGGGGGGGG GGGGGGGG GGGGGGGG GGGGGGGG\nHHHHHHHH HHHHHHHH HHHHHHHH HHHHHHHH\nIIIIIIII IIIIIIII IIIIIIII IIIIIIII\n\nJJJJJJJJ\nLLLLLLLL...\n\nOgg Page Header\nLetter  Length (bits)  Description\nA   32  0x4f676753, \"OggS\"\nB   8   stream_structure_version\nC   1   (0 no, 1 yes) last page of logical bitstream (eos)\nD   1   (0 no, 1 yes) first page of logical bitstream (bos)\nE   1   (0 no, 1 yes) continued packet\n\nF   64  absolute granule position\nG   32  stream serial number\nH   32  page sequence no\nI   32  page checksum\nJ   8   Number of page segments in the segment table\nL   n   Segment table (n=page_segments+26).\n        Segment table values sum to the total length of the packet.\n        Last value is always < 0xFF. Last lacing value will be 0x00 if evenly divisible by 0xFF.\n        \n*/\n\nimport { headerStore } from \"../../globals.js\";\nimport {\n  absoluteGranulePosition,\n  isContinuedPacket,\n  isFirstPage,\n  isLastPage,\n  pageSequenceNumber,\n  streamSerialNumber,\n  length,\n  pageChecksum,\n  frameLength,\n  streamStructureVersion,\n  pageSegmentTable,\n  pageSegmentBytes,\n  buffer,\n  subarray,\n  readRawData,\n  getHeader,\n  uint8Array,\n  dataView,\n} from \"../../constants.js\";\nimport { readInt64le } from \"../../utilities.js\";\n\nexport default class OggPageHeader {\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    const header = {};\n\n    // Must be at least 28 bytes.\n    let data = yield* codecParser[readRawData](28, readOffset);\n\n    // Bytes (1-4 of 28)\n    // Frame sync (must equal OggS): `AAAAAAAA|AAAAAAAA|AAAAAAAA|AAAAAAAA`:\n    if (\n      data[0] !== 0x4f || // O\n      data[1] !== 0x67 || // g\n      data[2] !== 0x67 || // g\n      data[3] !== 0x53 //    S\n    ) {\n      return null;\n    }\n\n    // Byte (5 of 28)\n    // * `BBBBBBBB`: stream_structure_version\n    header[streamStructureVersion] = data[4];\n\n    // Byte (6 of 28)\n    // * `00000CDE`\n    // * `00000...`: All zeros\n    // * `.....C..`: (0 no, 1 yes) last page of logical bitstream (eos)\n    // * `......D.`: (0 no, 1 yes) first page of logical bitstream (bos)\n    // * `.......E`: (0 no, 1 yes) continued packet\n    const zeros = data[5] & 0b11111000;\n    if (zeros) return null;\n\n    header[isLastPage] = !!(data[5] & 0b00000100);\n    header[isFirstPage] = !!(data[5] & 0b00000010);\n    header[isContinuedPacket] = !!(data[5] & 0b00000001);\n\n    const view = new dataView(uint8Array.from(data[subarray](0, 28))[buffer]);\n\n    // Byte (7-14 of 28)\n    // * `FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF`\n    // * Absolute Granule Position\n    header[absoluteGranulePosition] = readInt64le(view, 6);\n\n    // Byte (15-18 of 28)\n    // * `GGGGGGGG|GGGGGGGG|GGGGGGGG|GGGGGGGG`\n    // * Stream Serial Number\n    header[streamSerialNumber] = view.getInt32(14, true);\n\n    // Byte (19-22 of 28)\n    // * `HHHHHHHH|HHHHHHHH|HHHHHHHH|HHHHHHHH`\n    // * Page Sequence Number\n    header[pageSequenceNumber] = view.getInt32(18, true);\n\n    // Byte (23-26 of 28)\n    // * `IIIIIIII|IIIIIIII|IIIIIIII|IIIIIIII`\n    // * Page Checksum\n    header[pageChecksum] = view.getInt32(22, true);\n\n    // Byte (27 of 28)\n    // * `JJJJJJJJ`: Number of page segments in the segment table\n    const pageSegmentTableLength = data[26];\n    header[length] = pageSegmentTableLength + 27;\n\n    data = yield* codecParser[readRawData](header[length], readOffset); // read in the page segment table\n\n    header[frameLength] = 0;\n    header[pageSegmentTable] = [];\n    header[pageSegmentBytes] = uint8Array.from(\n      data[subarray](27, header[length]),\n    );\n\n    for (let i = 0, segmentLength = 0; i < pageSegmentTableLength; i++) {\n      const segmentByte = header[pageSegmentBytes][i];\n\n      header[frameLength] += segmentByte;\n      segmentLength += segmentByte;\n\n      if (segmentByte !== 0xff || i === pageSegmentTableLength - 1) {\n        header[pageSegmentTable].push(segmentLength);\n        segmentLength = 0;\n      }\n    }\n\n    return new OggPageHeader(header);\n  }\n\n  /**\n   * @private\n   * Call OggPageHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    headerStore.set(this, header);\n\n    this[absoluteGranulePosition] = header[absoluteGranulePosition];\n    this[isContinuedPacket] = header[isContinuedPacket];\n    this[isFirstPage] = header[isFirstPage];\n    this[isLastPage] = header[isLastPage];\n    this[pageSegmentTable] = header[pageSegmentTable];\n    this[pageSequenceNumber] = header[pageSequenceNumber];\n    this[pageChecksum] = header[pageChecksum];\n    this[streamSerialNumber] = header[streamSerialNumber];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { headerStore, frameStore } from \"../../globals.js\";\nimport {\n  codecFrames,\n  rawData,\n  absoluteGranulePosition,\n  crc32,\n  duration,\n  isContinuedPacket,\n  isFirstPage,\n  isLastPage,\n  pageSequenceNumber,\n  samples,\n  streamSerialNumber,\n  length,\n  pageChecksum,\n  frameLength,\n  subarray,\n  readRawData,\n  getFrame,\n  getHeader,\n} from \"../../constants.js\";\n\nimport Frame from \"../Frame.js\";\nimport OggPageHeader from \"./OggPageHeader.js\";\n\nexport default class OggPage extends Frame {\n  static *[getFrame](codecParser, headerCache, readOffset) {\n    const header = yield* OggPageHeader[getHeader](\n      codecParser,\n      headerCache,\n      readOffset,\n    );\n\n    if (header) {\n      const frameLengthValue = headerStore.get(header)[frameLength];\n      const headerLength = headerStore.get(header)[length];\n      const totalLength = headerLength + frameLengthValue;\n\n      const rawDataValue = (yield* codecParser[readRawData](totalLength, 0))[\n        subarray\n      ](0, totalLength);\n\n      const frame = rawDataValue[subarray](headerLength, totalLength);\n\n      return new OggPage(header, frame, rawDataValue);\n    } else {\n      return null;\n    }\n  }\n\n  constructor(header, frame, rawDataValue) {\n    super(header, frame);\n\n    frameStore.get(this)[length] = rawDataValue[length];\n\n    this[codecFrames] = [];\n    this[rawData] = rawDataValue;\n    this[absoluteGranulePosition] = header[absoluteGranulePosition];\n    this[crc32] = header[pageChecksum];\n    this[duration] = 0;\n    this[isContinuedPacket] = header[isContinuedPacket];\n    this[isFirstPage] = header[isFirstPage];\n    this[isLastPage] = header[isLastPage];\n    this[pageSequenceNumber] = header[pageSequenceNumber];\n    this[samples] = 0;\n    this[streamSerialNumber] = header[streamSerialNumber];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport CodecFrame from \"../CodecFrame.js\";\n\nexport default class OpusFrame extends CodecFrame {\n  constructor(data, header, samples) {\n    super(header, data, samples);\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\nhttps://tools.ietf.org/html/rfc7845.html\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      'O'      |      'p'      |      'u'      |      's'      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      'H'      |      'e'      |      'a'      |      'd'      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Version = 1  | Channel Count |           Pre-skip            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Input Sample Rate (Hz)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Output Gain (Q7.8 in dB)    | Mapping Family|               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               :\n|                                                               |\n:               Optional Channel Mapping Table...               :\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nLetter  Length (bits)  Description\nA  64  Magic Signature - OpusHead\nB  8   Version number - 00000001\nC  8   Output channel count (unsigned)\nD  16  Pre-skip (unsigned, little endian)\nE  32  Sample rate (unsigned, little endian)\nF  16  Output Gain (signed, little endian)\nG  8   Channel Mapping family (unsigned)\n\n// if(channel mapping !== 0)\nH  8   Stream count (unsigned)\nI  8   Coupled Stream Count (unsigned)\nJ  8*C Channel Mapping\n*/\n\nimport {\n  rate48000,\n  vorbisOpusChannelMapping,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  channels,\n  length,\n  bandwidth,\n  channelMappingFamily,\n  channelMappingTable,\n  coupledStreamCount,\n  frameCount,\n  frameSize,\n  hasOpusPadding,\n  inputSampleRate,\n  isVbr,\n  mode,\n  outputGain,\n  preSkip,\n  streamCount,\n  data,\n  buffer,\n  subarray,\n  getHeader,\n  setHeader,\n  getHeaderFromUint8Array,\n  uint8Array,\n  dataView,\n} from \"../../constants.js\";\nimport { bytesToString } from \"../../utilities.js\";\n\nimport CodecHeader from \"../CodecHeader.js\";\n\n/* prettier-ignore */\nconst channelMappingFamilies = {\n  0b00000000: vorbisOpusChannelMapping.slice(0,2),\n    /*\n    0: \"monophonic (mono)\"\n    1: \"stereo (left, right)\"\n    */\n  0b00000001: vorbisOpusChannelMapping\n    /*\n    0: \"monophonic (mono)\"\n    1: \"stereo (left, right)\"\n    2: \"linear surround (left, center, right)\"\n    3: \"quadraphonic (front left, front right, rear left, rear right)\"\n    4: \"5.0 surround (front left, front center, front right, rear left, rear right)\"\n    5: \"5.1 surround (front left, front center, front right, rear left, rear right, LFE)\"\n    6: \"6.1 surround (front left, front center, front right, side left, side right, rear center, LFE)\"\n    7: \"7.1 surround (front left, front center, front right, side left, side right, rear left, rear right, LFE)\"\n    */\n  // additional channel mappings are user defined\n};\n\nconst silkOnly = \"SILK-only\";\nconst celtOnly = \"CELT-only\";\nconst hybrid = \"Hybrid\";\n\nconst narrowBand = \"narrowband\";\nconst mediumBand = \"medium-band\";\nconst wideBand = \"wideband\";\nconst superWideBand = \"super-wideband\";\nconst fullBand = \"fullband\";\n\n//  0 1 2 3 4 5 6 7\n// +-+-+-+-+-+-+-+-+\n// | config  |s| c |\n// +-+-+-+-+-+-+-+-+\n// prettier-ignore\nconst configTable = {\n  0b00000000: { [mode]: silkOnly, [bandwidth]: narrowBand, [frameSize]: 10 },\n  0b00001000: { [mode]: silkOnly, [bandwidth]: narrowBand, [frameSize]: 20 },\n  0b00010000: { [mode]: silkOnly, [bandwidth]: narrowBand, [frameSize]: 40 },\n  0b00011000: { [mode]: silkOnly, [bandwidth]: narrowBand, [frameSize]: 60 },\n  0b00100000: { [mode]: silkOnly, [bandwidth]: mediumBand, [frameSize]: 10 },\n  0b00101000: { [mode]: silkOnly, [bandwidth]: mediumBand, [frameSize]: 20 },\n  0b00110000: { [mode]: silkOnly, [bandwidth]: mediumBand, [frameSize]: 40 },\n  0b00111000: { [mode]: silkOnly, [bandwidth]: mediumBand, [frameSize]: 60 },\n  0b01000000: { [mode]: silkOnly, [bandwidth]: wideBand, [frameSize]: 10 },\n  0b01001000: { [mode]: silkOnly, [bandwidth]: wideBand, [frameSize]: 20 },\n  0b01010000: { [mode]: silkOnly, [bandwidth]: wideBand, [frameSize]: 40 },\n  0b01011000: { [mode]: silkOnly, [bandwidth]: wideBand, [frameSize]: 60 },\n  0b01100000: { [mode]: hybrid, [bandwidth]: superWideBand, [frameSize]: 10 },\n  0b01101000: { [mode]: hybrid, [bandwidth]: superWideBand, [frameSize]: 20 },\n  0b01110000: { [mode]: hybrid, [bandwidth]: fullBand, [frameSize]: 10 },\n  0b01111000: { [mode]: hybrid, [bandwidth]: fullBand, [frameSize]: 20 },\n  0b10000000: { [mode]: celtOnly, [bandwidth]: narrowBand, [frameSize]: 2.5 },\n  0b10001000: { [mode]: celtOnly, [bandwidth]: narrowBand, [frameSize]: 5 },\n  0b10010000: { [mode]: celtOnly, [bandwidth]: narrowBand, [frameSize]: 10 },\n  0b10011000: { [mode]: celtOnly, [bandwidth]: narrowBand, [frameSize]: 20 },\n  0b10100000: { [mode]: celtOnly, [bandwidth]: wideBand, [frameSize]: 2.5 },\n  0b10101000: { [mode]: celtOnly, [bandwidth]: wideBand, [frameSize]: 5 },\n  0b10110000: { [mode]: celtOnly, [bandwidth]: wideBand, [frameSize]: 10 },\n  0b10111000: { [mode]: celtOnly, [bandwidth]: wideBand, [frameSize]: 20 },\n  0b11000000: { [mode]: celtOnly, [bandwidth]: superWideBand, [frameSize]: 2.5 },\n  0b11001000: { [mode]: celtOnly, [bandwidth]: superWideBand, [frameSize]: 5 },\n  0b11010000: { [mode]: celtOnly, [bandwidth]: superWideBand, [frameSize]: 10 },\n  0b11011000: { [mode]: celtOnly, [bandwidth]: superWideBand, [frameSize]: 20 },\n  0b11100000: { [mode]: celtOnly, [bandwidth]: fullBand, [frameSize]: 2.5 },\n  0b11101000: { [mode]: celtOnly, [bandwidth]: fullBand, [frameSize]: 5 },\n  0b11110000: { [mode]: celtOnly, [bandwidth]: fullBand, [frameSize]: 10 },\n  0b11111000: { [mode]: celtOnly, [bandwidth]: fullBand, [frameSize]: 20 },\n};\n\nexport default class OpusHeader extends CodecHeader {\n  static [getHeaderFromUint8Array](dataValue, packetData, headerCache) {\n    const header = {};\n\n    // get length of header\n    // Byte (10 of 19)\n    // * `CCCCCCCC`: Channel Count\n    header[channels] = dataValue[9];\n    // Byte (19 of 19)\n    // * `GGGGGGGG`: Channel Mapping Family\n    header[channelMappingFamily] = dataValue[18];\n\n    header[length] =\n      header[channelMappingFamily] !== 0 ? 21 + header[channels] : 19;\n\n    if (dataValue[length] < header[length])\n      throw new Error(\"Out of data while inside an Ogg Page\");\n\n    // Page Segment Bytes (1-2)\n    // * `AAAAA...`: Packet config\n    // * `.....B..`:\n    // * `......CC`: Packet code\n    const packetMode = packetData[0] & 0b00000011;\n    const packetLength = packetMode === 3 ? 2 : 1;\n\n    // Check header cache\n    const key =\n      bytesToString(dataValue[subarray](0, header[length])) +\n      bytesToString(packetData[subarray](0, packetLength));\n    const cachedHeader = headerCache[getHeader](key);\n\n    if (cachedHeader) return new OpusHeader(cachedHeader);\n\n    // Bytes (1-8 of 19): OpusHead - Magic Signature\n    if (key.substr(0, 8) !== \"OpusHead\") {\n      return null;\n    }\n\n    // Byte (9 of 19)\n    // * `00000001`: Version number\n    if (dataValue[8] !== 1) return null;\n\n    header[data] = uint8Array.from(dataValue[subarray](0, header[length]));\n\n    const view = new dataView(header[data][buffer]);\n\n    header[bitDepth] = 16;\n\n    // Byte (10 of 19)\n    // * `CCCCCCCC`: Channel Count\n    // set earlier to determine length\n\n    // Byte (11-12 of 19)\n    // * `DDDDDDDD|DDDDDDDD`: Pre skip\n    header[preSkip] = view.getUint16(10, true);\n\n    // Byte (13-16 of 19)\n    // * `EEEEEEEE|EEEEEEEE|EEEEEEEE|EEEEEEEE`: Sample Rate\n    header[inputSampleRate] = view.getUint32(12, true);\n    // Opus is always decoded at 48kHz\n    header[sampleRate] = rate48000;\n\n    // Byte (17-18 of 19)\n    // * `FFFFFFFF|FFFFFFFF`: Output Gain\n    header[outputGain] = view.getInt16(16, true);\n\n    // Byte (19 of 19)\n    // * `GGGGGGGG`: Channel Mapping Family\n    // set earlier to determine length\n    if (header[channelMappingFamily] in channelMappingFamilies) {\n      header[channelMode] =\n        channelMappingFamilies[header[channelMappingFamily]][\n          header[channels] - 1\n        ];\n      if (!header[channelMode]) return null;\n    }\n\n    if (header[channelMappingFamily] !== 0) {\n      // * `HHHHHHHH`: Stream count\n      header[streamCount] = dataValue[19];\n\n      // * `IIIIIIII`: Coupled Stream count\n      header[coupledStreamCount] = dataValue[20];\n\n      // * `JJJJJJJJ|...` Channel Mapping table\n      header[channelMappingTable] = [\n        ...dataValue[subarray](21, header[channels] + 21),\n      ];\n    }\n\n    const packetConfig = configTable[0b11111000 & packetData[0]];\n    header[mode] = packetConfig[mode];\n    header[bandwidth] = packetConfig[bandwidth];\n    header[frameSize] = packetConfig[frameSize];\n\n    // https://tools.ietf.org/html/rfc6716#appendix-B\n    switch (packetMode) {\n      case 0:\n        // 0: 1 frame in the packet\n        header[frameCount] = 1;\n        break;\n      case 1:\n      // 1: 2 frames in the packet, each with equal compressed size\n      case 2:\n        // 2: 2 frames in the packet, with different compressed sizes\n        header[frameCount] = 2;\n        break;\n      case 3:\n        // 3: an arbitrary number of frames in the packet\n        header[isVbr] = !!(0b10000000 & packetData[1]);\n        header[hasOpusPadding] = !!(0b01000000 & packetData[1]);\n        header[frameCount] = 0b00111111 & packetData[1];\n        break;\n      default:\n        return null;\n    }\n\n    // set header cache\n    {\n      const {\n        length,\n        data: headerData,\n        channelMappingFamily,\n        ...codecUpdateFields\n      } = header;\n\n      headerCache[setHeader](key, header, codecUpdateFields);\n    }\n\n    return new OpusHeader(header);\n  }\n\n  /**\n   * @private\n   * Call OpusHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[data] = header[data];\n    this[bandwidth] = header[bandwidth];\n    this[channelMappingFamily] = header[channelMappingFamily];\n    this[channelMappingTable] = header[channelMappingTable];\n    this[coupledStreamCount] = header[coupledStreamCount];\n    this[frameCount] = header[frameCount];\n    this[frameSize] = header[frameSize];\n    this[hasOpusPadding] = header[hasOpusPadding];\n    this[inputSampleRate] = header[inputSampleRate];\n    this[isVbr] = header[isVbr];\n    this[mode] = header[mode];\n    this[outputGain] = header[outputGain];\n    this[preSkip] = header[preSkip];\n    this[streamCount] = header[streamCount];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../../globals.js\";\nimport {\n  codecFrames,\n  data,\n  pageSequenceNumber,\n  codec,\n  segments,\n  logError,\n  parseOggPage,\n  enable,\n  getHeaderFromUint8Array,\n  preSkip,\n  frameSize,\n  frameCount,\n  sampleRate,\n} from \"../../constants.js\";\nimport Parser from \"../Parser.js\";\nimport OpusFrame from \"./OpusFrame.js\";\nimport OpusHeader from \"./OpusHeader.js\";\n\nexport default class OpusParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = OpusFrame;\n    this.Header = OpusHeader;\n\n    onCodec(this[codec]);\n    this._identificationHeader = null;\n    this._preSkipRemaining = null;\n  }\n\n  get [codec]() {\n    return \"opus\";\n  }\n\n  /**\n   * @todo implement continued page support\n   */\n  [parseOggPage](oggPage) {\n    if (oggPage[pageSequenceNumber] === 0) {\n      // Identification header\n\n      this._headerCache[enable]();\n      this._identificationHeader = oggPage[data];\n    } else if (oggPage[pageSequenceNumber] === 1) {\n      // OpusTags\n    } else {\n      oggPage[codecFrames] = frameStore\n        .get(oggPage)\n        [segments].map((segment) => {\n          const header = OpusHeader[getHeaderFromUint8Array](\n            this._identificationHeader,\n            segment,\n            this._headerCache,\n          );\n\n          if (header) {\n            if (this._preSkipRemaining === null)\n              this._preSkipRemaining = header[preSkip];\n\n            let samples =\n              ((header[frameSize] * header[frameCount]) / 1000) *\n              header[sampleRate];\n\n            if (this._preSkipRemaining > 0) {\n              this._preSkipRemaining -= samples;\n              samples =\n                this._preSkipRemaining < 0 ? -this._preSkipRemaining : 0;\n            }\n\n            return new OpusFrame(segment, header, samples);\n          }\n\n          this._codecParser[logError](\n            \"Failed to parse Ogg Opus Header\",\n            \"Not a valid Ogg Opus file\",\n          );\n        });\n    }\n\n    return oggPage;\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport CodecFrame from \"../CodecFrame.js\";\n\nexport default class VorbisFrame extends CodecFrame {\n  constructor(data, header, samples) {\n    super(header, data, samples);\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\n\n1  1) [packet_type] : 8 bit value\n2  2) 0x76, 0x6f, 0x72, 0x62, 0x69, 0x73: the characters ’v’,’o’,’r’,’b’,’i’,’s’ as six octets\n\nLetter bits Description\nA      8    Packet type\nB      48   Magic signature (vorbis)\nC      32   Version number\nD      8    Channels\nE      32   Sample rate\nF      32   Bitrate Maximum (signed)\nG      32   Bitrate Nominal (signed)\nH      32   Bitrate Minimum (signed)\nI      4    blocksize 1\nJ      4    blocksize 0\nK      1    Framing flag\n*/\n\nimport {\n  vorbisOpusChannelMapping,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  channels,\n  length,\n  bitrateMaximum,\n  bitrateMinimum,\n  bitrateNominal,\n  blocksize0,\n  blocksize1,\n  data,\n  vorbisComments,\n  vorbisSetup,\n  version,\n  buffer,\n  subarray,\n  getHeader,\n  setHeader,\n  getHeaderFromUint8Array,\n  uint8Array,\n  dataView,\n} from \"../../constants.js\";\nimport { bytesToString } from \"../../utilities.js\";\n\nimport CodecHeader from \"../CodecHeader.js\";\n\nconst blockSizes = {\n  // 0b0110: 64,\n  // 0b0111: 128,\n  // 0b1000: 256,\n  // 0b1001: 512,\n  // 0b1010: 1024,\n  // 0b1011: 2048,\n  // 0b1100: 4096,\n  // 0b1101: 8192\n};\nfor (let i = 0; i < 8; i++) blockSizes[i + 6] = 2 ** (6 + i);\n\nexport default class VorbisHeader extends CodecHeader {\n  static [getHeaderFromUint8Array](\n    dataValue,\n    headerCache,\n    vorbisCommentsData,\n    vorbisSetupData,\n  ) {\n    // Must be at least 30 bytes.\n    if (dataValue[length] < 30)\n      throw new Error(\"Out of data while inside an Ogg Page\");\n\n    // Check header cache\n    const key = bytesToString(dataValue[subarray](0, 30));\n    const cachedHeader = headerCache[getHeader](key);\n    if (cachedHeader) return new VorbisHeader(cachedHeader);\n\n    const header = { [length]: 30 };\n\n    // Bytes (1-7 of 30): /01vorbis - Magic Signature\n    if (key.substr(0, 7) !== \"\\x01vorbis\") {\n      return null;\n    }\n\n    header[data] = uint8Array.from(dataValue[subarray](0, 30));\n    const view = new dataView(header[data][buffer]);\n\n    // Byte (8-11 of 30)\n    // * `CCCCCCCC|CCCCCCCC|CCCCCCCC|CCCCCCCC`: Version number\n    header[version] = view.getUint32(7, true);\n    if (header[version] !== 0) return null;\n\n    // Byte (12 of 30)\n    // * `DDDDDDDD`: Channel Count\n    header[channels] = dataValue[11];\n    header[channelMode] =\n      vorbisOpusChannelMapping[header[channels] - 1] || \"application defined\";\n\n    // Byte (13-16 of 30)\n    // * `EEEEEEEE|EEEEEEEE|EEEEEEEE|EEEEEEEE`: Sample Rate\n    header[sampleRate] = view.getUint32(12, true);\n\n    // Byte (17-20 of 30)\n    // * `FFFFFFFF|FFFFFFFF|FFFFFFFF|FFFFFFFF`: Bitrate Maximum\n    header[bitrateMaximum] = view.getInt32(16, true);\n\n    // Byte (21-24 of 30)\n    // * `GGGGGGGG|GGGGGGGG|GGGGGGGG|GGGGGGGG`: Bitrate Nominal\n    header[bitrateNominal] = view.getInt32(20, true);\n\n    // Byte (25-28 of 30)\n    // * `HHHHHHHH|HHHHHHHH|HHHHHHHH|HHHHHHHH`: Bitrate Minimum\n    header[bitrateMinimum] = view.getInt32(24, true);\n\n    // Byte (29 of 30)\n    // * `IIII....` Blocksize 1\n    // * `....JJJJ` Blocksize 0\n    header[blocksize1] = blockSizes[(dataValue[28] & 0b11110000) >> 4];\n    header[blocksize0] = blockSizes[dataValue[28] & 0b00001111];\n    if (header[blocksize0] > header[blocksize1]) return null;\n\n    // Byte (29 of 30)\n    // * `00000001` Framing bit\n    if (dataValue[29] !== 0x01) return null;\n\n    header[bitDepth] = 32;\n    header[vorbisSetup] = vorbisSetupData;\n    header[vorbisComments] = vorbisCommentsData;\n\n    {\n      // set header cache\n      const {\n        length,\n        data,\n        version,\n        vorbisSetup,\n        vorbisComments,\n        ...codecUpdateFields\n      } = header;\n      headerCache[setHeader](key, header, codecUpdateFields);\n    }\n\n    return new VorbisHeader(header);\n  }\n\n  /**\n   * @private\n   * Call VorbisHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[bitrateMaximum] = header[bitrateMaximum];\n    this[bitrateMinimum] = header[bitrateMinimum];\n    this[bitrateNominal] = header[bitrateNominal];\n    this[blocksize0] = header[blocksize0];\n    this[blocksize1] = header[blocksize1];\n    this[data] = header[data];\n    this[vorbisComments] = header[vorbisComments];\n    this[vorbisSetup] = header[vorbisSetup];\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../../globals.js\";\nimport { BitReader, reverse } from \"../../utilities.js\";\nimport {\n  data,\n  codec,\n  blocksize0,\n  blocksize1,\n  codecFrames,\n  segments,\n  vorbis,\n  logWarning,\n  parseOggPage,\n  enable,\n  getHeaderFromUint8Array,\n} from \"../../constants.js\";\n\nimport Parser from \"../Parser.js\";\nimport VorbisFrame from \"./VorbisFrame.js\";\nimport VorbisHeader from \"./VorbisHeader.js\";\n\nexport default class VorbisParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = VorbisFrame;\n\n    onCodec(this[codec]);\n\n    this._identificationHeader = null;\n    this._setupComplete = false;\n\n    this._prevBlockSize = null;\n  }\n\n  get [codec]() {\n    return vorbis;\n  }\n\n  [parseOggPage](oggPage) {\n    oggPage[codecFrames] = [];\n\n    for (const oggPageSegment of frameStore.get(oggPage)[segments]) {\n      if (oggPageSegment[0] === 1) {\n        // Identification header\n\n        this._headerCache[enable]();\n        this._identificationHeader = oggPage[data];\n        this._setupComplete = false;\n      } else if (oggPageSegment[0] === 3) {\n        // comment header\n\n        this._vorbisComments = oggPageSegment;\n      } else if (oggPageSegment[0] === 5) {\n        // setup header\n\n        this._vorbisSetup = oggPageSegment;\n        this._mode = this._parseSetupHeader(oggPageSegment);\n        this._setupComplete = true;\n      } else if (this._setupComplete) {\n        const header = VorbisHeader[getHeaderFromUint8Array](\n          this._identificationHeader,\n          this._headerCache,\n          this._vorbisComments,\n          this._vorbisSetup,\n        );\n\n        if (header) {\n          oggPage[codecFrames].push(\n            new VorbisFrame(\n              oggPageSegment,\n              header,\n              this._getSamples(oggPageSegment, header),\n            ),\n          );\n        } else {\n          this._codecParser[logError](\n            \"Failed to parse Ogg Vorbis Header\",\n            \"Not a valid Ogg Vorbis file\",\n          );\n        }\n      }\n    }\n\n    return oggPage;\n  }\n\n  _getSamples(segment, header) {\n    const blockFlag =\n      this._mode.blockFlags[(segment[0] >> 1) & this._mode.mask];\n\n    const currentBlockSize = blockFlag\n      ? header[blocksize1]\n      : header[blocksize0];\n\n    // data is not returned on the first frame, but is used to prime the decoder\n    // https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-590004\n    const samplesValue =\n      this._prevBlockSize === null\n        ? 0\n        : (this._prevBlockSize + currentBlockSize) / 4;\n\n    this._prevBlockSize = currentBlockSize;\n\n    return samplesValue;\n  }\n\n  // https://gitlab.xiph.org/xiph/liboggz/-/blob/master/src/liboggz/oggz_auto.c#L911\n  // https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/vorbis_parser.c\n  /*\n   * This is the format of the mode data at the end of the packet for all\n   * Vorbis Version 1 :\n   *\n   * [ 6:number_of_modes ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:framing(1) ]\n   *\n   * e.g.:\n   *\n   * MsB         LsB\n   *              <-\n   * 0 0 0 0 0 1 0 0\n   * 0 0 1 0 0 0 0 0\n   * 0 0 1 0 0 0 0 0\n   * 0 0 1|0 0 0 0 0\n   * 0 0 0 0|0|0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0 0 0|0 0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0 0 0|0 0 0 0\n   * 0 0 0|1|0 0 0 0 |\n   * 0 0 0 0 0 0 0 0 V\n   * 0 0 0|0 0 0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0|1 0 0 0 0 0\n   *\n   * The simplest way to approach this is to start at the end\n   * and read backwards to determine the mode configuration.\n   *\n   * liboggz and ffmpeg both use this method.\n   */\n  _parseSetupHeader(setup) {\n    const bitReader = new BitReader(setup);\n    const mode = {\n      count: 0,\n      blockFlags: [],\n    };\n\n    // sync with the framing bit\n    while ((bitReader.read(1) & 0x01) !== 1) {}\n\n    let modeBits;\n    // search in reverse to parse out the mode entries\n    // limit mode count to 63 so previous block flag will be in first packet byte\n    while (mode.count < 64 && bitReader.position > 0) {\n      reverse(bitReader.read(8)); // read mapping\n\n      // 16 bits transform type, 16 bits window type, all values must be zero\n      let currentByte = 0;\n      while (bitReader.read(8) === 0x00 && currentByte++ < 3) {} // a non-zero value may indicate the end of the mode entries, or invalid data\n\n      if (currentByte === 4) {\n        // transform type and window type were all zeros\n        modeBits = bitReader.read(7); // modeBits may need to be used in the next iteration if this is the last mode entry\n        mode.blockFlags.unshift(modeBits & 0x01); // read and store mode number -> block flag\n        bitReader.position += 6; // go back 6 bits so next iteration starts right after the block flag\n        mode.count++;\n      } else {\n        // transform type and window type were not all zeros\n        // check for mode count using previous iteration modeBits\n        if (((reverse(modeBits) & 0b01111110) >> 1) + 1 !== mode.count) {\n          this._codecParser[logWarning](\n            \"vorbis derived mode count did not match actual mode count\",\n          );\n        }\n\n        break;\n      }\n    }\n\n    // xxxxxxxa packet type\n    // xxxxxxbx mode count (number of mode count bits)\n    // xxxxxcxx previous window flag\n    // xxxxdxxx next window flag\n    mode.mask = (1 << Math.log2(mode.count)) - 1;\n\n    return mode;\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { headerStore, frameStore } from \"../../globals.js\";\nimport { bytesToString, concatBuffers } from \"../../utilities.js\";\nimport {\n  header,\n  pageSequenceNumber,\n  pageSegmentBytes,\n  pageSegmentTable,\n  codec,\n  data,\n  length,\n  samples,\n  segments,\n  subarray,\n  vorbis,\n  mapFrameStats,\n  logWarning,\n  fixedLengthFrameSync,\n  parseFrame,\n  parseOggPage,\n  reset,\n  uint8Array,\n  isLastPage,\n  streamSerialNumber,\n  absoluteGranulePosition,\n} from \"../../constants.js\";\n\nimport Parser from \"../../codecs/Parser.js\";\nimport OggPage from \"./OggPage.js\";\nimport OggPageHeader from \"./OggPageHeader.js\";\n\nimport FLACParser from \"../../codecs/flac/FLACParser.js\";\nimport OpusParser from \"../../codecs/opus/OpusParser.js\";\nimport VorbisParser from \"../../codecs/vorbis/VorbisParser.js\";\n\nclass OggStream {\n  constructor(codecParser, headerCache, onCodec) {\n    this._codecParser = codecParser;\n    this._headerCache = headerCache;\n    this._onCodec = onCodec;\n\n    this._continuedPacket = new uint8Array();\n    this._codec = null;\n    this._isSupported = null;\n    this._previousAbsoluteGranulePosition = null;\n  }\n\n  get [codec]() {\n    return this._codec || \"\";\n  }\n\n  _updateCodec(codec, Parser) {\n    if (this._codec !== codec) {\n      this._headerCache[reset]();\n      this._parser = new Parser(\n        this._codecParser,\n        this._headerCache,\n        this._onCodec,\n      );\n      this._codec = codec;\n    }\n  }\n\n  _checkCodecSupport({ data }) {\n    const idString = bytesToString(data[subarray](0, 8));\n\n    switch (idString) {\n      case \"fishead\\0\":\n        return false; // ignore ogg skeleton packets\n      case \"OpusHead\":\n        this._updateCodec(\"opus\", OpusParser);\n        return true;\n      case /^\\x7fFLAC/.test(idString) && idString:\n        this._updateCodec(\"flac\", FLACParser);\n        return true;\n      case /^\\x01vorbis/.test(idString) && idString:\n        this._updateCodec(vorbis, VorbisParser);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  _checkPageSequenceNumber(oggPage) {\n    if (\n      oggPage[pageSequenceNumber] !== this._pageSequenceNumber + 1 &&\n      this._pageSequenceNumber > 1 &&\n      oggPage[pageSequenceNumber] > 1\n    ) {\n      this._codecParser[logWarning](\n        \"Unexpected gap in Ogg Page Sequence Number.\",\n        `Expected: ${this._pageSequenceNumber + 1}, Got: ${\n          oggPage[pageSequenceNumber]\n        }`,\n      );\n    }\n\n    this._pageSequenceNumber = oggPage[pageSequenceNumber];\n  }\n\n  _parsePage(oggPage) {\n    if (this._isSupported === null) {\n      this._pageSequenceNumber = oggPage[pageSequenceNumber];\n      this._isSupported = this._checkCodecSupport(oggPage);\n    }\n\n    this._checkPageSequenceNumber(oggPage);\n\n    const oggPageStore = frameStore.get(oggPage);\n    const headerData = headerStore.get(oggPageStore[header]);\n\n    let offset = 0;\n    oggPageStore[segments] = headerData[pageSegmentTable].map((segmentLength) =>\n      oggPage[data][subarray](offset, (offset += segmentLength)),\n    );\n\n    // prepend any existing continued packet data\n    if (this._continuedPacket[length]) {\n      oggPageStore[segments][0] = concatBuffers(\n        this._continuedPacket,\n        oggPageStore[segments][0],\n      );\n\n      this._continuedPacket = new uint8Array();\n    }\n\n    // save any new continued packet data\n    if (\n      headerData[pageSegmentBytes][headerData[pageSegmentBytes][length] - 1] ===\n      0xff\n    ) {\n      this._continuedPacket = concatBuffers(\n        this._continuedPacket,\n        oggPageStore[segments].pop(),\n      );\n    }\n\n    // set total samples in this ogg page\n    if (this._previousAbsoluteGranulePosition !== null) {\n      oggPage[samples] = Number(\n        oggPage[absoluteGranulePosition] -\n          this._previousAbsoluteGranulePosition,\n      );\n    }\n\n    this._previousAbsoluteGranulePosition = oggPage[absoluteGranulePosition];\n\n    if (this._isSupported) {\n      const frame = this._parser[parseOggPage](oggPage);\n      this._codecParser[mapFrameStats](frame);\n\n      return frame;\n    } else {\n      return oggPage;\n    }\n  }\n}\n\nexport default class OggParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n\n    this._onCodec = onCodec;\n    this.Frame = OggPage;\n    this.Header = OggPageHeader;\n\n    this._streams = new Map();\n    this._currentSerialNumber = null;\n  }\n\n  get [codec]() {\n    const oggStream = this._streams.get(this._currentSerialNumber);\n\n    return oggStream ? oggStream.codec : \"\";\n  }\n\n  *[parseFrame]() {\n    const oggPage = yield* this[fixedLengthFrameSync](true);\n    this._currentSerialNumber = oggPage[streamSerialNumber];\n\n    let oggStream = this._streams.get(this._currentSerialNumber);\n    if (!oggStream) {\n      oggStream = new OggStream(\n        this._codecParser,\n        this._headerCache,\n        this._onCodec,\n      );\n      this._streams.set(this._currentSerialNumber, oggStream);\n    }\n\n    if (oggPage[isLastPage]) this._streams.delete(this._currentSerialNumber);\n\n    return oggStream._parsePage(oggPage);\n  }\n}\n","/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { crc32Function, concatBuffers } from \"./utilities.js\";\nimport {\n  header,\n  sampleRate,\n  bitrate,\n  length,\n  frameNumber,\n  data,\n  samples,\n  codec,\n  codecFrames,\n  totalBytesOut,\n  totalSamples,\n  totalDuration,\n  crc32,\n  duration,\n  subarray,\n  readRawData,\n  incrementRawData,\n  mapCodecFrameStats,\n  mapFrameStats,\n  logWarning,\n  logError,\n  parseFrame,\n  checkCodecUpdate,\n  reset,\n  isLastPage,\n} from \"./constants.js\";\nimport HeaderCache from \"./codecs/HeaderCache.js\";\nimport MPEGParser from \"./codecs/mpeg/MPEGParser.js\";\nimport AACParser from \"./codecs/aac/AACParser.js\";\nimport FLACParser from \"./codecs/flac/FLACParser.js\";\nimport OggParser from \"./containers/ogg/OggParser.js\";\n\nconst noOp = () => {};\n\nexport default class CodecParser {\n  constructor(\n    mimeType,\n    {\n      onCodec,\n      onCodecHeader,\n      onCodecUpdate,\n      enableLogging = false,\n      enableFrameCRC32 = true,\n    } = {},\n  ) {\n    this._inputMimeType = mimeType;\n    this._onCodec = onCodec || noOp;\n    this._onCodecHeader = onCodecHeader || noOp;\n    this._onCodecUpdate = onCodecUpdate;\n    this._enableLogging = enableLogging;\n    this._crc32 = enableFrameCRC32 ? crc32Function : noOp;\n\n    this[reset]();\n  }\n\n  /**\n   * @public\n   * @returns The detected codec\n   */\n  get [codec]() {\n    return this._parser ? this._parser[codec] : \"\";\n  }\n\n  [reset]() {\n    this._headerCache = new HeaderCache(\n      this._onCodecHeader,\n      this._onCodecUpdate,\n    );\n\n    this._generator = this._getGenerator();\n    this._generator.next();\n  }\n\n  /**\n   * @public\n   * @description Generator function that yields any buffered CodecFrames and resets the CodecParser\n   * @returns {Iterable<CodecFrame|OggPage>} Iterator that operates over the codec data.\n   * @yields {CodecFrame|OggPage} Parsed codec or ogg page data\n   */\n  *flush() {\n    this._flushing = true;\n\n    for (let i = this._generator.next(); i.value; i = this._generator.next()) {\n      yield i.value;\n    }\n\n    this._flushing = false;\n\n    this[reset]();\n  }\n\n  /**\n   * @public\n   * @description Generator function takes in a Uint8Array of data and returns a CodecFrame from the data for each iteration\n   * @param {Uint8Array} chunk Next chunk of codec data to read\n   * @returns {Iterable<CodecFrame|OggPage>} Iterator that operates over the codec data.\n   * @yields {CodecFrame|OggPage} Parsed codec or ogg page data\n   */\n  *parseChunk(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      yield i.value;\n    }\n  }\n\n  /**\n   * @public\n   * @description Parses an entire file and returns all of the contained frames.\n   * @param {Uint8Array} fileData Coded data to read\n   * @returns {Array<CodecFrame|OggPage>} CodecFrames\n   */\n  parseAll(fileData) {\n    return [...this.parseChunk(fileData), ...this.flush()];\n  }\n\n  /**\n   * @private\n   */\n  *_getGenerator() {\n    if (this._inputMimeType.match(/aac/)) {\n      this._parser = new AACParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/mpeg/)) {\n      this._parser = new MPEGParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/flac/)) {\n      this._parser = new FLACParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/ogg/)) {\n      this._parser = new OggParser(this, this._headerCache, this._onCodec);\n    } else {\n      throw new Error(`Unsupported Codec ${mimeType}`);\n    }\n\n    this._frameNumber = 0;\n    this._currentReadPosition = 0;\n    this._totalBytesIn = 0;\n    this._totalBytesOut = 0;\n    this._totalSamples = 0;\n    this._sampleRate = undefined;\n\n    this._rawData = new Uint8Array(0);\n\n    // start parsing out frames\n    while (true) {\n      const frame = yield* this._parser[parseFrame]();\n      if (frame) yield frame;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {number} minSize Minimum bytes to have present in buffer\n   * @returns {Uint8Array} rawData\n   */\n  *[readRawData](minSize = 0, readOffset = 0) {\n    let rawData;\n\n    while (this._rawData[length] <= minSize + readOffset) {\n      rawData = yield;\n\n      if (this._flushing) return this._rawData[subarray](readOffset);\n\n      if (rawData) {\n        this._totalBytesIn += rawData[length];\n        this._rawData = concatBuffers(this._rawData, rawData);\n      }\n    }\n\n    return this._rawData[subarray](readOffset);\n  }\n\n  /**\n   * @protected\n   * @param {number} increment Bytes to increment codec data\n   */\n  [incrementRawData](increment) {\n    this._currentReadPosition += increment;\n    this._rawData = this._rawData[subarray](increment);\n  }\n\n  /**\n   * @protected\n   */\n  [mapCodecFrameStats](frame) {\n    this._sampleRate = frame[header][sampleRate];\n\n    frame[header][bitrate] =\n      frame[duration] > 0\n        ? Math.round(frame[data][length] / frame[duration]) * 8\n        : 0;\n    frame[frameNumber] = this._frameNumber++;\n    frame[totalBytesOut] = this._totalBytesOut;\n    frame[totalSamples] = this._totalSamples;\n    frame[totalDuration] = (this._totalSamples / this._sampleRate) * 1000;\n    frame[crc32] = this._crc32(frame[data]);\n\n    this._headerCache[checkCodecUpdate](\n      frame[header][bitrate],\n      frame[totalDuration],\n    );\n\n    this._totalBytesOut += frame[data][length];\n    this._totalSamples += frame[samples];\n  }\n\n  /**\n   * @protected\n   */\n  [mapFrameStats](frame) {\n    if (frame[codecFrames]) {\n      // Ogg container\n      if (frame[isLastPage]) {\n        // cut any excess samples that fall outside of the absolute granule position\n        // some streams put invalid data in absolute granule position, so only do this\n        // for the end of the stream\n        let absoluteGranulePositionSamples = frame[samples];\n\n        frame[codecFrames].forEach((codecFrame) => {\n          const untrimmedCodecSamples = codecFrame[samples];\n\n          if (absoluteGranulePositionSamples < untrimmedCodecSamples) {\n            codecFrame[samples] =\n              absoluteGranulePositionSamples > 0\n                ? absoluteGranulePositionSamples\n                : 0;\n            codecFrame[duration] =\n              (codecFrame[samples] / codecFrame[header][sampleRate]) * 1000;\n          }\n\n          absoluteGranulePositionSamples -= untrimmedCodecSamples;\n\n          this[mapCodecFrameStats](codecFrame);\n        });\n      } else {\n        frame[samples] = 0;\n        frame[codecFrames].forEach((codecFrame) => {\n          frame[samples] += codecFrame[samples];\n          this[mapCodecFrameStats](codecFrame);\n        });\n      }\n\n      frame[duration] = (frame[samples] / this._sampleRate) * 1000 || 0;\n      frame[totalSamples] = this._totalSamples;\n      frame[totalDuration] =\n        (this._totalSamples / this._sampleRate) * 1000 || 0;\n      frame[totalBytesOut] = this._totalBytesOut;\n    } else {\n      this[mapCodecFrameStats](frame);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _log(logger, messages) {\n    if (this._enableLogging) {\n      const stats = [\n        `${codec}:         ${this[codec]}`,\n        `inputMimeType: ${this._inputMimeType}`,\n        `readPosition:  ${this._currentReadPosition}`,\n        `totalBytesIn:  ${this._totalBytesIn}`,\n        `${totalBytesOut}: ${this._totalBytesOut}`,\n      ];\n\n      const width = Math.max(...stats.map((s) => s[length]));\n\n      messages.push(\n        `--stats--${\"-\".repeat(width - 9)}`,\n        ...stats,\n        \"-\".repeat(width),\n      );\n\n      logger(\n        \"codec-parser\",\n        messages.reduce((acc, message) => acc + \"\\n  \" + message, \"\"),\n      );\n    }\n  }\n\n  /**\n   * @protected\n   */\n  [logWarning](...messages) {\n    this._log(console.warn, messages);\n  }\n\n  /**\n   * @protected\n   */\n  [logError](...messages) {\n    this._log(console.error, messages);\n  }\n}\n","import CodecParser from \"./src/CodecParser.js\";\nimport * as constants from \"./src/constants.js\";\n\nexport default CodecParser;\n\nexport const absoluteGranulePosition = constants.absoluteGranulePosition;\nexport const bandwidth = constants.bandwidth;\nexport const bitDepth = constants.bitDepth;\nexport const bitrate = constants.bitrate;\nexport const bitrateMaximum = constants.bitrateMaximum;\nexport const bitrateMinimum = constants.bitrateMinimum;\nexport const bitrateNominal = constants.bitrateNominal;\nexport const buffer = constants.buffer;\nexport const bufferFullness = constants.bufferFullness;\nexport const codec = constants.codec;\nexport const codecFrames = constants.codecFrames;\nexport const coupledStreamCount = constants.coupledStreamCount;\nexport const crc = constants.crc;\nexport const crc16 = constants.crc16;\nexport const crc32 = constants.crc32;\nexport const data = constants.data;\nexport const description = constants.description;\nexport const duration = constants.duration;\nexport const emphasis = constants.emphasis;\nexport const hasOpusPadding = constants.hasOpusPadding;\nexport const header = constants.header;\nexport const isContinuedPacket = constants.isContinuedPacket;\nexport const isCopyrighted = constants.isCopyrighted;\nexport const isFirstPage = constants.isFirstPage;\nexport const isHome = constants.isHome;\nexport const isLastPage = constants.isLastPage;\nexport const isOriginal = constants.isOriginal;\nexport const isPrivate = constants.isPrivate;\nexport const isVbr = constants.isVbr;\nexport const layer = constants.layer;\nexport const length = constants.length;\nexport const mode = constants.mode;\nexport const modeExtension = constants.modeExtension;\nexport const mpeg = constants.mpeg;\nexport const mpegVersion = constants.mpegVersion;\nexport const numberAACFrames = constants.numberAACFrames;\nexport const outputGain = constants.outputGain;\nexport const preSkip = constants.preSkip;\nexport const profile = constants.profile;\nexport const protection = constants.protection;\nexport const rawData = constants.rawData;\nexport const segments = constants.segments;\nexport const subarray = constants.subarray;\nexport const version = constants.version;\nexport const vorbis = constants.vorbis;\nexport const vorbisComments = constants.vorbisComments;\nexport const vorbisSetup = constants.vorbisSetup;\nexport const blockingStrategy = constants.blockingStrategy;\nexport const blockSize = constants.blockSize;\nexport const blocksize0 = constants.blocksize0;\nexport const blocksize1 = constants.blocksize1;\nexport const channelMappingFamily = constants.channelMappingFamily;\nexport const channelMappingTable = constants.channelMappingTable;\nexport const channelMode = constants.channelMode;\nexport const channels = constants.channels;\nexport const copyrightId = constants.copyrightId;\nexport const copyrightIdStart = constants.copyrightIdStart;\nexport const frame = constants.frame;\nexport const frameCount = constants.frameCount;\nexport const frameLength = constants.frameLength;\nexport const frameNumber = constants.frameNumber;\nexport const framePadding = constants.framePadding;\nexport const frameSize = constants.frameSize;\nexport const inputSampleRate = constants.inputSampleRate;\nexport const pageChecksum = constants.pageChecksum;\nexport const pageSegmentTable = constants.pageSegmentTable;\nexport const pageSequenceNumber = constants.pageSequenceNumber;\nexport const sampleNumber = constants.sampleNumber;\nexport const sampleRate = constants.sampleRate;\nexport const samples = constants.samples;\nexport const streamCount = constants.streamCount;\nexport const streamInfo = constants.streamInfo;\nexport const streamSerialNumber = constants.streamSerialNumber;\nexport const streamStructureVersion = constants.streamStructureVersion;\nexport const totalBytesOut = constants.totalBytesOut;\nexport const totalDuration = constants.totalDuration;\nexport const totalSamples = constants.totalSamples;\n"],"names":["symbol","Symbol","channelMappings","left","center","right","front","side","rear","map","x","flatMap","y","z","join","lfe","monophonic","stereo","surround","getChannelMapping","channelCount","mappings","vorbisOpusChannelMapping","rate48000","rate44100","rate32000","rate24000","rate22050","rate16000","rate8000","absoluteGranulePosition","bandwidth","bitDepth","bitrate","bitrateMaximum","bitrateMinimum","bitrateNominal","buffer","bufferFullness","codec","codecFrames","coupledStreamCount","crc","crc16","crc32","data","description","duration","emphasis","hasOpusPadding","header","isContinuedPacket","isCopyrighted","isFirstPage","isHome","isLastPage","isOriginal","isPrivate","isVbr","layer","length","mode","modeExtension","mpeg","mpegVersion","numberAACFrames","outputGain","preSkip","profile","profileBits","protection","segments","subarray","version","vorbis","vorbisComments","vorbisSetup","block","blockingStrategy","blockingStrategyBits","blockSize","blocksize0","blocksize1","blockSizeBits","channel","channelMappingFamily","channelMappingTable","channelMode","channelModeBits","channels","copyright","copyrightId","copyrightIdStart","frame","frameCount","frameLength","Number","frameNumber","framePadding","frameSize","Rate","inputSampleRate","page","pageChecksum","pageSegmentBytes","pageSegmentTable","pageSequenceNumber","sample","sampleNumber","sampleRate","sampleRateBits","samples","stream","streamCount","streamInfo","streamSerialNumber","streamStructureVersion","total","totalBytesOut","totalDuration","totalSamples","readRawData","incrementRawData","mapCodecFrameStats","mapFrameStats","logWarning","logError","syncFrame","fixedLengthFrameSync","getHeader","setHeader","getFrame","parseFrame","parseOggPage","checkCodecUpdate","reset","enable","getHeaderFromUint8Array","checkFrameFooterCrc16","uint8Array","Uint8Array","dataView","DataView","reserved","bad","free","none","sixteenBitCRC","getCrcTable","crcTable","crcInitialValueFunction","crcFunction","byte","bit","crc8Table","b","flacCrc16Table","Uint16Array","crc32Table","Uint32Array","i","push","j","crc32Function","dataLength","crcChunkSize","concatBuffers","buffers","reduce","acc","buf","offset","set","bytesToString","bytes","String","fromCharCode","reverseTable","reverse","val","BitReader","constructor","this","_data","_pos","position","read","bits","Math","floor","HeaderCache","onCodecHeader","onCodecUpdate","_onCodecHeader","_onCodecUpdate","_isEnabled","_headerCache","Map","_codecUpdateData","WeakMap","_codecHeaderSent","_codecShouldUpdate","_bitrate","codecData","get","_currentHeader","key","_updateCurrentHeader","codecUpdateFields","headerStore","frameStore","Parser","codecParser","headerCache","_codecParser","frameData","Frame","ignoreNextFrame","_flushing","Header","headerValue","dataValue","header$1","CodecFrame","readOffset","frameLengthValue","samplesValue","super","unsynchronizationFlag","extendedHeaderFlag","experimentalFlag","footerPresent","ID3v2","getID3v2Header","CodecHeader","bitrateMatrix","calcBitrate","idx","interval","intervalOffset","bands","to31","layer12ModeExtensions","bitrateIndex","v2","v1","intensityStereo","msStereo","on","off","layer3ModeExtensions","layersValues","mpegVersionDescription","isoIec","mpegVersions","protectionValues","emphasisValues","channelModes","channels$1","MPEGHeader","id3v2Header","cachedHeader","mpegVersionValues","layerBits","layerValues","MPEGFrame","MPEGParser","onCodec","profileValues","sampleRates","channelModeValues","AACHeader","Object","assign","protectionBit","privateBit","bufferFullnessBits","audioSpecificConfig","setUint16","AACFrame","AACParser","FLACFrame","_getFrameFooterCrc16","expectedCrc16","actualCrc16","flacCrc16","streamInfoValue","getFromStreamInfo","blockingStrategyValues","blockSizeValues","sampleRateValues","channelAssignments","bitDepthValues","FLACHeader","_decodeUTF8Int","value","zeroMask","shift","next","channelAssignment","decodedUtf8","crc8","FLACParser","_getNextFrameSyncOffset","secondByte","nextHeaderOffset","oggPage","_streamInfo","segment","filter","OggPageHeader","view","from","getBigInt64","sign","getUint8","firstPart","getUint32","secondPart","console","warn","readInt64le","getInt32","pageSegmentTableLength","segmentLength","segmentByte","OggPage","headerLength","totalLength","rawDataValue","OpusFrame","channelMappingFamilies","slice","silkOnly","celtOnly","hybrid","narrowBand","mediumBand","wideBand","superWideBand","fullBand","configTable","OpusHeader","packetData","Error","packetMode","packetLength","substr","getUint16","getInt16","packetConfig","headerData","OpusParser","_identificationHeader","_preSkipRemaining","VorbisFrame","blockSizes","VorbisHeader","vorbisCommentsData","vorbisSetupData","VorbisParser","_setupComplete","_prevBlockSize","oggPageSegment","_vorbisComments","_vorbisSetup","_mode","_parseSetupHeader","_getSamples","currentBlockSize","blockFlags","mask","setup","bitReader","count","modeBits","currentByte","unshift","log2","OggStream","_onCodec","_continuedPacket","_codec","_isSupported","_previousAbsoluteGranulePosition","_updateCodec","_parser","_checkCodecSupport","idString","test","_checkPageSequenceNumber","_pageSequenceNumber","_parsePage","oggPageStore","pop","OggParser","_streams","_currentSerialNumber","oggStream","delete","noOp","CodecParser","mimeType","enableLogging","enableFrameCRC32","_inputMimeType","_enableLogging","_crc32","_generator","_getGenerator","flush","parseChunk","chunk","parseAll","fileData","match","_frameNumber","_currentReadPosition","_totalBytesIn","_totalBytesOut","_totalSamples","_sampleRate","undefined","_rawData","minSize","rawData","increment","round","absoluteGranulePositionSamples","forEach","codecFrame","untrimmedCodecSamples","_log","logger","messages","stats","width","max","s","repeat","message","error","constants.absoluteGranulePosition","constants.codecFrames","constants.coupledStreamCount","constants.data","constants.header","constants.isLastPage","constants.preSkip","constants.vorbisComments","constants.vorbisSetup","constants.channelMappingTable","constants.channels","constants.streamCount","constants.totalSamples"],"mappings":"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"}