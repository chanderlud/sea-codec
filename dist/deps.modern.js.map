{"version":3,"file":"deps.modern.js","sources":["../node_modules/audio-decode/audio-decode.js","../node_modules/audio-buffer/index.js","../deps.js","../node_modules/audio-type/audio-type.js"],"sourcesContent":["/**\n * Web-Audio-API decoder\n * @module  audio-decode\n */\n\nimport getType from 'audio-type';\nimport AudioBufferShim from 'audio-buffer';\n\nconst AudioBuffer = globalThis.AudioBuffer || AudioBufferShim;\n\n/**\n * Decode an audio buffer.\n *\n * @param {ArrayBuffer | Uint8Array} buf - The audio data to decode.\n * @returns {Promise<AudioBuffer>} A promise that resolves to the decoded audio buffer.\n * @throws {Error} Throws an error if the decode target is invalid or if the audio format is not supported.\n */\nexport default async function audioDecode(buf) {\n\tif (!buf && !(buf.length || buf.buffer)) throw Error('Bad decode target')\n\tbuf = new Uint8Array(buf.buffer || buf)\n\n\tlet type = getType(buf);\n\n\tif (!type) throw Error('Cannot detect audio format');\n\n\tif (!decoders[type]) throw Error('Missing decoder for ' + type + ' format')\n\n\treturn decoders[type](buf)\n};\n\nexport const decoders = {\n\tasync oga(buf) {\n\t\tlet { decoder } = decoders.oga\n\t\tif (!decoder) {\n\t\t\tlet { OggVorbisDecoder } = await import('@wasm-audio-decoders/ogg-vorbis')\n\t\t\tawait (decoders.oga.decoder = decoder = new OggVorbisDecoder()).ready;\n\t\t} else await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decodeFile(buf))\n\t},\n\tasync mp3(buf) {\n\t\tlet { decoder } = decoders.mp3\n\t\tif (!decoder) {\n\t\t\tconst { MPEGDecoder } = await import('mpg123-decoder')\n\t\t\tawait (decoders.mp3.decoder = decoder = new MPEGDecoder()).ready;\n\t\t}\n\t\telse await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decode(buf))\n\t},\n\tasync flac(buf) {\n\t\tlet { decoder } = decoders.flac\n\t\tif (!decoder) {\n\t\t\tconst { FLACDecoder } = await import('@wasm-audio-decoders/flac')\n\t\t\tawait (decoders.flac.decoder = decoder = new FLACDecoder()).ready\n\t\t}\n\t\telse await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decode(buf))\n\t},\n\tasync opus(buf) {\n\t\tlet { decoder } = decoders.opus\n\t\tif (!decoder) {\n\t\t\tconst { OggOpusDecoder } = await import('ogg-opus-decoder')\n\t\t\tawait (decoders.opus.decoder = decoder = new OggOpusDecoder()).ready\n\t\t}\n\t\telse await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decodeFile(buf))\n\t},\n\tasync wav(buf) {\n\t\tlet { decode } = decoders.wav\n\t\tif (!decode) {\n\t\t\tlet module = await import('node-wav')\n\t\t\tdecode = decoders.wav.decode = module.default.decode\n\t\t}\n\t\treturn buf && createBuffer(await decode(buf))\n\t},\n\tasync qoa(buf) {\n\t\tlet { decode } = decoders.qoa\n\t\tif (!decode) {\n\t\t\tdecoders.qoa.decode = decode = (await import('qoa-format')).decode\n\t\t}\n\t\treturn buf && createBuffer(await decode(buf))\n\t}\n}\n\nfunction createBuffer({ channelData, sampleRate }) {\n\tlet audioBuffer = new AudioBuffer({\n\t\tsampleRate,\n\t\tlength: channelData[0].length,\n\t\tnumberOfChannels: channelData.length\n\t})\n\tfor (let ch = 0; ch < channelData.length; ch++) audioBuffer.getChannelData(ch).set(channelData[ch])\n\treturn audioBuffer\n}\n","/**\n * AudioBuffer class\n */\nexport default class AudioBuffer {\n\t/**\n\t * Create AudioBuffer instance.\n\t * @constructor\n\t * @param {Object} options - buffer init options.\n\t * @param {number} options.length - buffer length in samples.\n\t * @param {number} options.sampleRate - buffer sample rate.\n\t * @param {number} options.numberOfChannels - number of channels.\n\t */\n\tconstructor(options) {\n\t\tif (!options) throw TypeError('options argument is required')\n\t\tif (!options.sampleRate) throw TypeError('options.sampleRate is required')\n\t\tif (options.sampleRate < 3000 || options.sampleRate > 768000) throw TypeError('options.sampleRate must be within 3000..768000')\n\t\tif (!options.length) throw TypeError('options.length must be more than 0')\n\n\t\tthis.sampleRate = options.sampleRate\n\t\tthis.numberOfChannels = options.numberOfChannels || 1\n\t\tthis.length = options.length | 0\n\t\tthis.duration = this.length / this.sampleRate\n\n\t\t//data is stored as a planar sequence\n\t\tthis._data = new Float32Array(this.length * this.numberOfChannels)\n\n\t\t//channels data is cached as subarrays\n\t\tthis._channelData = []\n\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\tthis._channelData.push(this._data.subarray(c * this.length, (c+1) * this.length))\n\t\t}\n\t}\n\n\t/**\n\t * Return data associated with the channel.\n\t * @param {number} channel - Channel index, starting from 0.\n\t * @return {Float32Array} Array containing the data.\n\t */\n\tgetChannelData (channel) {\n\t\tif (channel >= this.numberOfChannels || channel < 0 || channel == null) throw Error('Cannot getChannelData: channel number (' + channel + ') exceeds number of channels (' + this.numberOfChannels + ')');\n\n\t\treturn this._channelData[channel]\n\t}\n\n\n\t/**\n\t * Place data to the destination buffer, starting from the position.\n\t * @param {Float32Array} destination - Destination array to write data to.\n\t * @param {number} channelNumber - Channel to take data from.\n\t * @param {number} startInChannel - Data offset in channel to read from.\n\t */\n\tcopyFromChannel (destination, channelNumber, startInChannel) {\n\t\tif (startInChannel == null) startInChannel = 0;\n\t\tvar data = this._channelData[channelNumber]\n\t\tfor (var i = startInChannel, j = 0; i < this.length && j < destination.length; i++, j++) {\n\t\t\tdestination[j] = data[i];\n\t\t}\n\t}\n\n\n\t/**\n\t * Place data from the source to the channel, starting (in self) from the position.\n\t * @param {Float32Array | Array} source - source array to read data from.\n\t * @param {number} channelNumber - channel index to copy data to.\n\t * @param {number} startInChannel - offset in channel to copy data to.\n\t */\n\tcopyToChannel (source, channelNumber, startInChannel) {\n\t\tvar data = this._channelData[channelNumber]\n\n\t\tif (!startInChannel) startInChannel = 0;\n\n\t\tfor (var i = startInChannel, j = 0; i < this.length && j < source.length; i++, j++) {\n\t\t\tdata[i] = source[j];\n\t\t}\n\t}\n}\n","import npmAudioDecodeLib from \"audio-decode\";\n\nexport function decodeAudioFile(buffer) {\n  return npmAudioDecodeLib(buffer);\n}\n","export default function audioType (buf) {\n\tif (!buf) return;\n\n\tbuf = new Uint8Array(buf.buffer || buf)\n\n\tif (isWav(buf)) return 'wav';\n\tif (isMp3(buf)) return 'mp3';\n\tif (isFlac(buf)) return 'flac';\n\tif (isM4a(buf)) return 'm4a';\n\tif (isOpus(buf)) return 'opus'; // overlaps with ogg, so must come first\n\tif (isOgg(buf)) return 'oga';\n\tif (isQoa(buf)) return 'qoa';\n};\n\nexport function isMp3 (buf) {\n\tif (!buf || buf.length < 3) return\n\n\treturn (buf[0] === 0x49 && buf[1] === 0x44 && buf[2] === 0x33) || // id3\n\t\t( buf[0] === 0xff && (buf[1] & 0xe0) === 0xe0 ) || // no tag\n\t\t( buf[0] === 0x54 && buf[1] === 0x41 && buf[2] === 0x47) // 'TAG'\n};\n\nexport function isWav(buf) {\n\tif (!buf || buf.length < 12) return\n\n\treturn buf[0] === 82 &&\n\t\tbuf[1] === 73 &&\n\t\tbuf[2] === 70 &&\n\t\tbuf[3] === 70 &&\n\t\tbuf[8] === 87 &&\n\t\tbuf[9] === 65 &&\n\t\tbuf[10] === 86 &&\n\t\tbuf[11] === 69;\n}\n\nexport function isOgg(buf) {\n\tif (!buf || buf.length < 4) return;\n\n\treturn  buf[0] === 79 &&\n\t\tbuf[1] === 103 &&\n\t\tbuf[2] === 103 &&\n\t\tbuf[3] === 83;\n}\n\nexport function isFlac(buf) {\n\tif (!buf || buf.length < 4) return;\n\n\treturn buf[0] === 102 &&\n\t\tbuf[1] === 76 &&\n\t\tbuf[2] === 97 &&\n\t\tbuf[3] === 67;\n}\n\nexport function isM4a(buf) {\n\tif (!buf || buf.length < 8) return;\n\n\treturn (buf[4] === 102 &&\n\t\tbuf[5] === 116 &&\n\t\tbuf[6] === 121 &&\n\t\tbuf[7] === 112) || (\n\t\t\tbuf[0] === 77 &&\n\t\t\tbuf[1] === 52 &&\n\t\t\tbuf[2] === 65 &&\n\t\t\tbuf[3] === 32\n\t\t);\n}\n\nexport function isOpus(buf) {\n\tif (!buf || buf.length < 36) return\n\n\t// Bytes 0 to 3: detect general OGG (OPUS is OGG)\n\t// Bytes 28 to 35: detect OPUS\n\treturn buf[0] === 79 &&\n\t\tbuf[1] === 103 &&\n\t\tbuf[2] === 103 &&\n\t\tbuf[3] === 83 &&\n\t\tbuf[28] === 79 &&\n\t\tbuf[29] === 112 &&\n\t\tbuf[30] === 117 &&\n\t\tbuf[31] === 115 &&\n\t\tbuf[32] === 72 &&\n\t\tbuf[33] === 101 &&\n\t\tbuf[34] === 97 &&\n\t\tbuf[35] === 100;\n}\n\nexport function isQoa(buf) {\n\tif (!buf) return\n\treturn (buf[0] === 0x71 && buf[1] === 0x6f && buf[2] === 0x61 && buf[3] === 0x66)\n}"],"names":["AudioBuffer","globalThis","constructor","options","TypeError","sampleRate","length","this","numberOfChannels","duration","_data","Float32Array","_channelData","c","push","subarray","getChannelData","channel","Error","copyFromChannel","destination","channelNumber","startInChannel","data","i","j","copyToChannel","source","decoders","oga","buf","decoder","reset","OggVorbisDecoder","import","ready","createBuffer","decodeFile","mp3","MPEGDecoder","decode","flac","FLACDecoder","opus","OggOpusDecoder","wav","module","then","n","default","qoa","channelData","audioBuffer","ch","set","decodeAudioFile","buffer","async","type","isWav","Uint8Array","isMp3","isFlac","isM4a","isOpus","isOgg","isQoa","getType","npmAudioDecodeLib"],"mappings":"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"}